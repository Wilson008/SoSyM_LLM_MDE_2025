// automatically generated by Xtext
grammar org.prettyprinter.sml.SML with org.eclipse.xtext.common.Terminals
import "http://www.scenariotools.org/sml"
import "http://www.scenariotools.org/sml/expressions/ScenarioExpressions"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore


Specification returns Specification:
    {Specification}
          (imports+=DummyExprClass)*  
    'specification'
    name=ID
    '{'
        ->('domain'  domains+=[ecore::EPackage|FQN]  )*
        ('contexts'  contexts+=[ecore::EPackage|FQN]  )*
          ('controllable' '{'(controllableEClasses+=[ecore::EClass])*  '}')?
         channelOptions=ChannelOptions
          ('non-spontaneous events' '{'(nonSpontaneousOperations+=[ecore::ETypedElement|FQN] (  nonSpontaneousOperations+=[ecore::ETypedElement|FQN])*  )?'}')?
          ('parameter ranges' '{'(eventParameterRanges+=EventParameterRanges ( "," eventParameterRanges+=EventParameterRanges)*  )?'}')?
          (containedCollaborations+=NestedCollaboration   |
          ('include collaboration' includedCollaborations+=[Collaboration]  ))*
    '}';

DummyExprClass returns DummyExprClass:
    DummyExprClass_Impl | Interaction;

InteractionFragment returns InteractionFragment:
    Interaction | ModalMessage | Alternative | Loop | Parallel |  VariableFragment  | ConditionFragment | TimedConditionFragment;

BindingExpression returns BindingExpression:
    FeatureAccessBindingExpression ;

AbstractRanges returns AbstractRanges:
    '['(IntegerRanges | StringRanges | EnumRanges)']';

DummyExprClass_Impl returns DummyExprClass:
    {DummyExprClass}
    'DummyExprClass'
    ;

Collaboration returns Collaboration:
    
          (imports+=DummyExprClass)*  
          ('domain' domains+=[ecore::EPackage|FQN]  )*
          ('contexts' contexts+=[ecore::EPackage|FQN]  )*
    'collaboration'
    name=ID
    '{'
          (roles+=Role)*  
          (scenarios+=Scenario)*  
    '}';

EventParameterRanges returns EventParameterRanges:
    
    
    
         event=[ecore::ETypedElement|FQN]
          '('rangesForParameter+=RangesForParameter ( "," rangesForParameter+=RangesForParameter)*  ')'
    ;

ChannelOptions returns ChannelOptions:
    {ChannelOptions}
    ('channels'
    '{'
    (allMessagesRequireLinks?='allMessagesRequireLinks')?
          (messageChannels+=MessageChannel)*  
    '}')?;

Interaction returns Interaction:
    {Interaction}
    
    
          '{'(fragments+=InteractionFragment)*  '}'
        ( constraints=ConstraintBlock)?
    ;

ConstraintBlock returns ConstraintBlock:
    {ConstraintBlock}
    'constraints'
    '['
        ('consider'  consider+=ConstraintMessage   |
        'ignore'  ignore+=ConstraintMessage   |
        'forbidden'  forbidden+=ConstraintMessage   |
        'interrupt'  interrupt+=ConstraintMessage  )*
    ']';

ModalMessage returns ModalMessage:
    
    (strict?='strict')?
    ((monitored?='monitored')?
         expectationKind=ExpectationKind)?
         sender=[Role]
    '->'
         receiver=[Role] '.'
         modelElement=[ecore::ETypedElement]
        ('.' collectionModification=DummyDatatype)?
        ('('(  parameters+=ParameterBinding ( "," parameters+=ParameterBinding)*  )?')')?
    ;

Alternative returns Alternative:
    {Alternative}
    'Alternative'
    
          cases+=Case ( 'or' cases+=Case)*  
    ;

Loop returns Loop:
    
    'while'
    
        ( loopCondition=Condition)?
         bodyInteraction=Interaction
    ;

Parallel returns Parallel:
    {Parallel}
    'Parallel'
    
          parallelInteraction+=Interaction ( 'and' parallelInteraction+=Interaction)*  
    ;

WaitCondition returns WaitCondition:
    
    'wait'
    (strict?='strict')?
    (requested?='eventually')?
    '['
         conditionExpression=ConditionExpression
    ']';

InterruptCondition returns InterruptCondition:
    
    'interrupt'
    '['
         conditionExpression=ConditionExpression
    ']';

ViolationCondition returns ViolationCondition:
    
    'violation'
    '['
         conditionExpression=ConditionExpression
    ']';

Condition returns Condition:
    
    
    '['
         conditionExpression=ConditionExpression
    ']';

VariableFragment returns VariableFragment:
    
    
    
         expression=DummyExprClass
    ;

TimedViolationCondition returns TimedViolationCondition:
    
    'timed' 'violation'
    '['
         timedConditionExpression=DummyExprClass
    ']';

TimedInterruptCondition returns TimedInterruptCondition:
    
    'timed' 'interrupt'
    '['
         timedConditionExpression=DummyExprClass
    ']';

TimedWaitCondition returns TimedWaitCondition:
    
    'timed' 'wait'
    (strict?='strict')?
    (requested?='eventually')?
    '['
         timedConditionExpression=DummyExprClass
    ']';

Role returns Role:
    
    (static?='static' |
    'dynamic' (multiRole?='multi')?)
    'role'
         type=[ecore::EClass]
    name=ID
    
    ;

ParameterBinding returns ParameterBinding:
    
    
    
         bindingExpression=ParameterExpression
    ;

DummyDatatype returns DummyDatatype:
    'DummyDatatype' /* TODO: implement this rule and an appropriate IValueConverter */;

enum ExpectationKind returns ExpectationKind:
                 eventually = 'eventually' | urgent = 'urgent' | requested = 'requested' | committed = 'committed';

FeatureAccessBindingExpression returns FeatureAccessBindingExpression:
    
    
    
         featureaccess=DummyExprClass
    ;

WildcardParameterExpression returns WildcardParameterExpression:
    
    '*'
    ;

ValueParameterExpression returns ValueParameterExpression:
    
    
    
         value=DummyExprClass
    ;

VariableBindingParameterExpression returns VariableBindingParameterExpression:
    
    'bind'
    
         variable=DummyExprClass
    ;

Case returns Case:
    {Case}
    
    
        ( caseCondition=Condition)?
         caseInteraction=Interaction
    ;

ConditionExpression returns ConditionExpression:
    
    
    
         expression=DummyExprClass
    ;
    
Scenario returns Scenario:
    (singular?='singular')?
         kind=ScenarioKind
    'scenario'
    name=ID
    ((optimizeCost?='optimize' 'cost' ) |
         ('cost' '['cost=DOUBLE']'))?
        ('context'  contexts+=[ecore::EClass] ( "," contexts+=[ecore::EClass])*  )?
        ('bindings' '[' (roleBindings+=RoleBindingConstraint)* ']' )?
         ownedInteraction=Interaction
    ;

enum ScenarioKind returns ScenarioKind:
                assumption = 'assumption' | guarantee = 'guarantee' | existential = 'existential';

RoleBindingConstraint returns RoleBindingConstraint:
    
    
    
         role=[Role] '=' 
         bindingExpression=BindingExpression
    ;

RangesForParameter returns RangesForParameter:
    
    
    
         parameter=[ecore::ETypedElement]
         '=' ranges=AbstractRanges
    ;

IntegerRanges returns IntegerRanges:
    
    
    
         (min=(INT | SIGNEDINT) '..'
         max=(INT | SIGNEDINT))
        (','  values+=(INT | SIGNEDINT) ( "," values+=(INT | SIGNEDINT))*  )? | values+=(INT | SIGNEDINT) ("," values+=(INT | SIGNEDINT))*
    ;

StringRanges returns StringRanges:
    
    
    
          (values+=STRING ( "," values+=STRING)*  )
    ;

EnumRanges returns EnumRanges:
    
    
    
          (values+=[ecore::EEnumLiteral|FQNENUM] ( "," values+=[ecore::EEnumLiteral|FQNENUM])*  )
    ;

MessageChannel returns MessageChannel:
    
    
    
         event=[ecore::ETypedElement|FQN]
         'over' channelFeature=[ecore::EStructuralFeature|FQN]
    ;

ParameterExpression returns ParameterExpression:
    
    WildcardParameterExpression | ValueParameterExpression | VariableBindingParameterExpression
    ;
ConstraintMessage returns Message:
    
    
    
         sender=[Role] '->'
         receiver=[Role] '.'
         modelElement=[ecore::ETypedElement]
        ('.' collectionModification=DummyDatatype)?
        '('(  parameters+=ParameterBinding ( "," parameters+=ParameterBinding)*  )?')'
    ;



NestedCollaboration returns Collaboration:
    'collaboration'
    name=ID
    '{'
        roles+=Role*
        scenarios+=Scenario*
    '}';


FQN:
    ID ('.' ID)*;


TimedConditionFragment returns TimedConditionFragment:
    TimedWaitCondition | TimedInterruptCondition | TimedViolationCondition;


ConditionFragment returns ConditionFragment:
    WaitCondition | InterruptCondition | ViolationCondition;


FQNENUM:
    ID (':' ID)*;


DOUBLE returns ecore::EDouble:
	INT '.' INT;

SIGNEDINT returns ecore::EInt:
	INT;

