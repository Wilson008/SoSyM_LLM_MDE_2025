// automatically generated by Xtext
grammar org.omg.qvt10.myqvto.MyQvto with org.eclipse.xtext.common.Terminals

import "http://www.schema.omg.org/spec/QVT/1.0/qvtbase" 
import "http:///emof.ecore" as emof
import "http://www.schema.omg.org/spec/OCL/2.0/essentialocl" as essentialocl
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.schema.omg.org/spec/QVT/1.0/qvttemplate" as qvttemplate
import "http://www.schema.omg.org/spec/QVT/1.0/qvtoperational" as qvtoperational
import "http://www.schema.omg.org/spec/QVT/1.0/qvtrelation" as qvtrelation
import "http://www.schema.omg.org/spec/QVT/1.0/imperativeocl" as imperativeocl

TopLevelGO returns qvtoperational::TopLevelGO:
	{qvtoperational::TopLevelGO}
	'TopLevelGO'
	'{'
		('unit_element' '{' unit_element+=Module ( "," unit_element+=Module)* '}' )?
		('moduleimport' '{' moduleimport+=ModuleImport ( "," moduleimport+=ModuleImport)* '}' )?
	'}';

Module returns qvtoperational::Module:
	Module_Impl | Helper | OperationalTransformation | MappingOperation | Constructor | ContextualProperty | EntryOperation | Library | ModelType | TagGO | MetaModelGO | AccessDecl | TypeDef | ClassifierGO;




Type returns emof::Type:
	Class | DataType_Impl | Enumeration | PrimitiveType;







Element returns emof::Element:
	Class | DataType_Impl | Tag | Enumeration | Operation | Package | Parameter | EnumerationLiteral | Property | PrimitiveType | Comment;

NamedElement returns emof::NamedElement:
	Class | DataType_Impl | Enumeration | Operation | Package | Parameter | EnumerationLiteral | Property | PrimitiveType;






OclExpression returns essentialocl::OclExpression:
	BooleanLiteralExp | UnlimitedNaturalExp | IfExp | LetExp | PropertyCallExp | VariableExp | TypeExp | IteratorExp | StringLiteralExp | IntegerLiteralExp | OperationCallExp | RealLiteralExp | IterateExp | CollectionLiteralExp | TupleLiteralExp | NullLiteralExp | InvalidLiteralExp | EnumLiteralExp;

VarParameter returns qvtoperational::VarParameter:
	VarParameter_Impl | MappingParameter | ModelParameter;

ImperativeOperation returns qvtoperational::ImperativeOperation:
	ImperativeOperation_Impl | Helper | MappingOperation | Constructor | ContextualProperty | EntryOperation | TagGO | AccessDecl | TypeDef | ClassifierGO;

OperationBody returns qvtoperational::OperationBody:
	OperationBody_Impl | MappingBody | ConstructorBody;























CollectionLiteralPart returns essentialocl::CollectionLiteralPart:
	CollectionItem | CollectionRange;













TemplateExp returns qvttemplate::TemplateExp:
	ObjectTemplateExp | CollectionTemplateExp;


CollectionType returns essentialocl::CollectionType:
	BagType | OrderedSetType | SequenceType | SetType;






























Module_Impl returns qvtoperational::Module:
	{qvtoperational::Module}
	'Module'
	'{'
		('name' name=String0)?
		('uri' uri=String0)?
		('isBlackbox' isBlackbox=Boolean)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('entry' entry=[emof::Operation|EString])?
		('configProperty' '(' configProperty+=[emof::Property|EString] ( "," configProperty+=[emof::Property|EString])* ')' )?
		('usedModelType' '(' usedModelType+=[qvtoperational::ModelType|EString] ( "," usedModelType+=[qvtoperational::ModelType|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
	'}';

ModuleImport returns qvtoperational::ModuleImport:
	'ModuleImport'
	'{'
		('kind' kind=ImportKind)?
		('identifier' '{' identifier+=EString ( "," identifier+=EString)* '}' )?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('binding' '(' binding+=[qvtoperational::ModelType|EString] ( "," binding+=[qvtoperational::ModelType|EString])* ')' )?
		'importedModule' importedModule=[qvtoperational::Module|EString]
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('unit' unit=UnitRefGO)?
	'}';

Tag returns emof::Tag:
	{emof::Tag}
	'Tag'
	'{'
		('value' value=String0)?
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('element' '(' element+=[emof::Element|EString] ( "," element+=[emof::Element|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

Comment returns emof::Comment:
	{emof::Comment}
	'Comment'
	'{'
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('annotatedElement' '(' annotatedElement+=[emof::NamedElement|EString] ( "," annotatedElement+=[emof::NamedElement|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

String0 returns emof::String:
	'String' /* TODO: implement this rule and an appropriate IValueConverter */;

Package returns emof::Package:
	{emof::Package}
	'Package'
	'{'
		('name' name=String0)?
		('uri' uri=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
	'}';

Operation returns emof::Operation:
	{emof::Operation}
	'Operation'
	'{'
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('raisedException' '(' raisedException+=[emof::Type|EString] ( "," raisedException+=[emof::Type|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
	'}';

Property returns emof::Property:
	{emof::Property}
	'Property'
	'{'
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('name' name=String0)?
		('isReadOnly' isReadOnly=Boolean)?
		('isDerived' isDerived=Boolean)?
		('isComposite' isComposite=Boolean)?
		('isId' isId=Boolean)?
		('default' default=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('opposite' opposite=[emof::Property|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

ModelType returns qvtoperational::ModelType:
	{qvtoperational::ModelType}
	'ModelType'
	'{'
		('name' name=String0)?
		('uri' uri=String0)?
		('isBlackbox' isBlackbox=Boolean)?
		('isAbstract' isAbstract=Boolean)?
		('conformanceKind' conformanceKind=String0)?
		('compliance_kind' compliance_kind=EString)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('entry' entry=[emof::Operation|EString])?
		('configProperty' '(' configProperty+=[emof::Property|EString] ( "," configProperty+=[emof::Property|EString])* ')' )?
		('usedModelType' '(' usedModelType+=[qvtoperational::ModelType|EString] ( "," usedModelType+=[qvtoperational::ModelType|EString])* ')' )?
		('superClass' '(' superClass+=[emof::Class|EString] ( "," superClass+=[emof::Class|EString])* ')' )?
		('metamodel' '(' metamodel+=[emof::Package|EString] ( "," metamodel+=[emof::Package|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		('ownedAttribute' '{' ownedAttribute+=Property ( "," ownedAttribute+=Property)* '}' )?
		('ownedOperation' '{' ownedOperation+=Operation ( "," ownedOperation+=Operation)* '}' )?
		('additionalCondition' '{' additionalCondition+=ExpressionGO ( "," additionalCondition+=ExpressionGO)* '}' )?
		('packageref_list' '{' packageref_list+=PackageRefGO ( "," packageref_list+=PackageRefGO)* '}' )?
		('modeltype_where' modeltype_where=ExpressionBlock)?
	'}';

Boolean returns emof::Boolean:
	'Boolean' /* TODO: implement this rule and an appropriate IValueConverter */;

Variable returns essentialocl::Variable:
	{essentialocl::Variable}
	'Variable'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('bindParameter' bindParameter=[emof::Parameter|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('initExpression' initExpression=OclExpression)?
	'}';

Helper returns qvtoperational::Helper:
	'Helper'
	'{'
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('name' name=String0)?
		('uri' uri=String0)?
		('isBlackbox' isBlackbox=Boolean)?
		('isQuery' isQuery=Boolean)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('raisedException' '(' raisedException+=[emof::Type|EString] ( "," raisedException+=[emof::Type|EString])* ')' )?
		('overridden' overridden=[qvtoperational::ImperativeOperation|EString])?
		('entry' entry=[emof::Operation|EString])?
		('configProperty' '(' configProperty+=[emof::Property|EString] ( "," configProperty+=[emof::Property|EString])* ')' )?
		('usedModelType' '(' usedModelType+=[qvtoperational::ModelType|EString] ( "," usedModelType+=[qvtoperational::ModelType|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
		('body' body=OperationBody)?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		'helper_header' helper_header=HelperHeader
		('expression' expression=ExpressionGO)?
		('expression_block' expression_block=ExpressionBlock)?
	'}';

OperationalTransformation returns qvtoperational::OperationalTransformation:
	'OperationalTransformation'
	'{'
		('name' name=String0)?
		('uri' uri=String0)?
		('isBlackbox' isBlackbox=Boolean)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('entry' entry=[emof::Operation|EString])?
		('configProperty' '(' configProperty+=[emof::Property|EString] ( "," configProperty+=[emof::Property|EString])* ')' )?
		('usedModelType' '(' usedModelType+=[qvtoperational::ModelType|EString] ( "," usedModelType+=[qvtoperational::ModelType|EString])* ')' )?
		('intermediateClass' '(' intermediateClass+=[emof::Class|EString] ( "," intermediateClass+=[emof::Class|EString])* ')' )?
		('refined' refined=[qvtrelation::RelationalTransformation|EString])?
		('intermediateProperty' '(' intermediateProperty+=[emof::Property|EString] ( "," intermediateProperty+=[emof::Property|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		('modelParameter' '{' modelParameter+=ModelParameter ( "," modelParameter+=ModelParameter)* '}' )?
		('relation' '{' relation+=Relation ( "," relation+=Relation)* '}' )?
		'transformation_h' transformation_h=TransformationHeader
		('module_element' '{' module_element+=ImperativeOperation ( "," module_element+=ImperativeOperation)* '}' )?
	'}';

MappingOperation returns qvtoperational::MappingOperation:
	'MappingOperation'
	'{'
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('name' name=String0)?
		('uri' uri=String0)?
		('isBlackbox' isBlackbox=Boolean)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('raisedException' '(' raisedException+=[emof::Type|EString] ( "," raisedException+=[emof::Type|EString])* ')' )?
		('overridden' overridden=[qvtoperational::ImperativeOperation|EString])?
		('entry' entry=[emof::Operation|EString])?
		('configProperty' '(' configProperty+=[emof::Property|EString] ( "," configProperty+=[emof::Property|EString])* ')' )?
		('usedModelType' '(' usedModelType+=[qvtoperational::ModelType|EString] ( "," usedModelType+=[qvtoperational::ModelType|EString])* ')' )?
		('disjunct' '(' disjunct+=[qvtoperational::MappingOperation|EString] ( "," disjunct+=[qvtoperational::MappingOperation|EString])* ')' )?
		('refinedRelation' refinedRelation=[qvtrelation::Relation|EString])?
		('merged' '(' merged+=[qvtoperational::MappingOperation|EString] ( "," merged+=[qvtoperational::MappingOperation|EString])* ')' )?
		('inherited' '(' inherited+=[qvtoperational::MappingOperation|EString] ( "," inherited+=[qvtoperational::MappingOperation|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
		('body' body=OperationBody)?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		('when' '{' when+=ExpressionGO ( "," when+=ExpressionGO)* '}' )?
		('where' '{' where+=ExpressionGO ( "," where+=ExpressionGO)* '}' )?
		'mapping_full_header' mapping_full_header=MappingFullHeader
		('mapping_body' mapping_body=MappingBody)?
	'}';

Constructor returns qvtoperational::Constructor:
	'Constructor'
	'{'
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('name' name=String0)?
		('uri' uri=String0)?
		('isBlackbox' isBlackbox=Boolean)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('raisedException' '(' raisedException+=[emof::Type|EString] ( "," raisedException+=[emof::Type|EString])* ')' )?
		('overridden' overridden=[qvtoperational::ImperativeOperation|EString])?
		('entry' entry=[emof::Operation|EString])?
		('configProperty' '(' configProperty+=[emof::Property|EString] ( "," configProperty+=[emof::Property|EString])* ')' )?
		('usedModelType' '(' usedModelType+=[qvtoperational::ModelType|EString] ( "," usedModelType+=[qvtoperational::ModelType|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
		('body' body=OperationBody)?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		'constructor_header' constructor_header=ConstructorHeader
		('expression_block' expression_block=ExpressionBlock)?
	'}';

ContextualProperty returns qvtoperational::ContextualProperty:
	'ContextualProperty'
	'{'
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('name' name=String0)?
		('uri' uri=String0)?
		('isBlackbox' isBlackbox=Boolean)?
		'property_key' '{' property_key+=PropertyKey ( "," property_key+=PropertyKey)* '}' 
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('raisedException' '(' raisedException+=[emof::Type|EString] ( "," raisedException+=[emof::Type|EString])* ')' )?
		('overridden' overridden=[qvtoperational::ImperativeOperation|EString])?
		('entry' entry=[emof::Operation|EString])?
		('configProperty' '(' configProperty+=[emof::Property|EString] ( "," configProperty+=[emof::Property|EString])* ')' )?
		('usedModelType' '(' usedModelType+=[qvtoperational::ModelType|EString] ( "," usedModelType+=[qvtoperational::ModelType|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
		('body' body=OperationBody)?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		('initExpression' initExpression=ExpressionGO)?
		'declarator' declarator=Declarator
	'}';

EntryOperation returns qvtoperational::EntryOperation:
	'EntryOperation'
	'{'
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('name' name=String0)?
		('uri' uri=String0)?
		('isBlackbox' isBlackbox=Boolean)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('raisedException' '(' raisedException+=[emof::Type|EString] ( "," raisedException+=[emof::Type|EString])* ')' )?
		('overridden' overridden=[qvtoperational::ImperativeOperation|EString])?
		('entry' entry=[emof::Operation|EString])?
		('configProperty' '(' configProperty+=[emof::Property|EString] ( "," configProperty+=[emof::Property|EString])* ')' )?
		('usedModelType' '(' usedModelType+=[qvtoperational::ModelType|EString] ( "," usedModelType+=[qvtoperational::ModelType|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
		('body' body=OperationBody)?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		'entry_header' entry_header=EntryHeader
		('expression_block' expression_block=ExpressionBlock)?
	'}';

Library returns qvtoperational::Library:
	'Library'
	'{'
		('name' name=String0)?
		('uri' uri=String0)?
		('isBlackbox' isBlackbox=Boolean)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('entry' entry=[emof::Operation|EString])?
		('configProperty' '(' configProperty+=[emof::Property|EString] ( "," configProperty+=[emof::Property|EString])* ')' )?
		('usedModelType' '(' usedModelType+=[qvtoperational::ModelType|EString] ( "," usedModelType+=[qvtoperational::ModelType|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		'library_h' library_h=LibraryHeader
		('module_element' '{' module_element+=ImperativeOperation ( "," module_element+=ImperativeOperation)* '}' )?
	'}';

TagGO returns qvtoperational::TagGO:
	'TagGO'
	'{'
		('name' name=String0)?
		('uri' uri=String0)?
		('isBlackbox' isBlackbox=Boolean)?
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		'tagid' tagid=EString
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('entry' entry=[emof::Operation|EString])?
		('configProperty' '(' configProperty+=[emof::Property|EString] ( "," configProperty+=[emof::Property|EString])* ')' )?
		('usedModelType' '(' usedModelType+=[qvtoperational::ModelType|EString] ( "," usedModelType+=[qvtoperational::ModelType|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('raisedException' '(' raisedException+=[emof::Type|EString] ( "," raisedException+=[emof::Type|EString])* ')' )?
		('overridden' overridden=[qvtoperational::ImperativeOperation|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
		('body' body=OperationBody)?
		'scoped_identifier' scoped_identifier=ScopedIdentifier
		('tagvalue' tagvalue=ExpressionGO)?
	'}';

MetaModelGO returns qvtoperational::MetaModelGO:
	'MetaModelGO'
	'{'
		('name' name=String0)?
		('uri' uri=String0)?
		('isBlackbox' isBlackbox=Boolean)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('entry' entry=[emof::Operation|EString])?
		('configProperty' '(' configProperty+=[emof::Property|EString] ( "," configProperty+=[emof::Property|EString])* ')' )?
		('usedModelType' '(' usedModelType+=[qvtoperational::ModelType|EString] ( "," usedModelType+=[qvtoperational::ModelType|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		'metamodel_h' metamodel_h=MetaModelHeader
		('metamodel_element' '{' metamodel_element+=MetaModelElement ( "," metamodel_element+=MetaModelElement)* '}' )?
	'}';

AccessDecl returns qvtoperational::AccessDecl:
	'AccessDecl'
	'{'
		('name' name=String0)?
		('uri' uri=String0)?
		('isBlackbox' isBlackbox=Boolean)?
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('entry' entry=[emof::Operation|EString])?
		('configProperty' '(' configProperty+=[emof::Property|EString] ( "," configProperty+=[emof::Property|EString])* ')' )?
		('usedModelType' '(' usedModelType+=[qvtoperational::ModelType|EString] ( "," usedModelType+=[qvtoperational::ModelType|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('raisedException' '(' raisedException+=[emof::Type|EString] ( "," raisedException+=[emof::Type|EString])* ')' )?
		('overridden' overridden=[qvtoperational::ImperativeOperation|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
		('body' body=OperationBody)?
		'access_usage' access_usage=AccessUsage
	'}';

TypeDef returns qvtoperational::TypeDef:
	'TypeDef'
	'{'
		('name' name=String0)?
		('uri' uri=String0)?
		('isBlackbox' isBlackbox=Boolean)?
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('entry' entry=[emof::Operation|EString])?
		('configProperty' '(' configProperty+=[emof::Property|EString] ( "," configProperty+=[emof::Property|EString])* ')' )?
		('usedModelType' '(' usedModelType+=[qvtoperational::ModelType|EString] ( "," usedModelType+=[qvtoperational::ModelType|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('raisedException' '(' raisedException+=[emof::Type|EString] ( "," raisedException+=[emof::Type|EString])* ')' )?
		('overridden' overridden=[qvtoperational::ImperativeOperation|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
		('body' body=OperationBody)?
		'typespec' typespec=TypeSpec
		('typedef_condition' typedef_condition=ExpressionGO)?
	'}';

ClassifierGO returns qvtoperational::ClassifierGO:
	'ClassifierGO'
	'{'
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('name' name=String0)?
		('uri' uri=String0)?
		('isBlackbox' isBlackbox=Boolean)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('raisedException' '(' raisedException+=[emof::Type|EString] ( "," raisedException+=[emof::Type|EString])* ')' )?
		('overridden' overridden=[qvtoperational::ImperativeOperation|EString])?
		('entry' entry=[emof::Operation|EString])?
		('configProperty' '(' configProperty+=[emof::Property|EString] ( "," configProperty+=[emof::Property|EString])* ')' )?
		('usedModelType' '(' usedModelType+=[qvtoperational::ModelType|EString] ( "," usedModelType+=[qvtoperational::ModelType|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
		('body' body=OperationBody)?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		'classifier_h' classifier_h=ClassifierHeader
		('classifier_feature_list' classifier_feature_list=ClassifierFeatureList)?
	'}';

Class returns emof::Class:
	{emof::Class}
	'Class'
	'{'
		('name' name=String0)?
		('isAbstract' isAbstract=Boolean)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('superClass' '(' superClass+=[emof::Class|EString] ( "," superClass+=[emof::Class|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedAttribute' '{' ownedAttribute+=Property ( "," ownedAttribute+=Property)* '}' )?
		('ownedOperation' '{' ownedOperation+=Operation ( "," ownedOperation+=Operation)* '}' )?
	'}';

DataType_Impl returns emof::DataType:
	{emof::DataType}
	'DataType'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

Enumeration returns emof::Enumeration:
	{emof::Enumeration}
	'Enumeration'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedLiteral' '{' ownedLiteral+=EnumerationLiteral ( "," ownedLiteral+=EnumerationLiteral)* '}' )?
	'}';

Parameter returns emof::Parameter:
	{emof::Parameter}
	'Parameter'
	'{'
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

EnumerationLiteral returns emof::EnumerationLiteral:
	{emof::EnumerationLiteral}
	'EnumerationLiteral'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

PrimitiveType returns emof::PrimitiveType:
	{emof::PrimitiveType}
	'PrimitiveType'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

Integer returns emof::Integer:
	'Integer' /* TODO: implement this rule and an appropriate IValueConverter */;

UnlimitedNatural returns emof::UnlimitedNatural:
	'UnlimitedNatural' /* TODO: implement this rule and an appropriate IValueConverter */;

ExpressionGO returns qvtoperational::ExpressionGO:
	{qvtoperational::ExpressionGO}
	'ExpressionGO'
	'{'
		('dummyContent' '{' dummyContent+=EString ( "," dummyContent+=EString)* '}' )?
	'}';

EString returns ecore::EString:
	STRING | ID;

PackageRefGO returns qvtoperational::PackageRefGO:
	{qvtoperational::PackageRefGO}
	'PackageRefGO'
	'{'
		('uri' uri=EString)?
		('scoped_identifier' scoped_identifier=ScopedIdentifier)?
	'}';

ExpressionBlock returns qvtoperational::ExpressionBlock:
	{qvtoperational::ExpressionBlock}
	'ExpressionBlock'
	'{'
		('expression_list' expression_list=ExpressionList)?
	'}';

ScopedIdentifier returns qvtoperational::ScopedIdentifier:
	{qvtoperational::ScopedIdentifier}
	'ScopedIdentifier'
	'{'
		('identifier' '{' identifier+=EString ( "," identifier+=EString)* '}' )?
	'}';

ExpressionList returns qvtoperational::ExpressionList:
	'ExpressionList'
	'{'
		'expression_semi_list' expression_semi_list=ExpressionSemiList
	'}';

ExpressionSemiList returns qvtoperational::ExpressionSemiList:
	{qvtoperational::ExpressionSemiList}
	'ExpressionSemiList'
	'{'
		('expression' '{' expression+=ExpressionGO ( "," expression+=ExpressionGO)* '}' )?
	'}';

BooleanLiteralExp returns essentialocl::BooleanLiteralExp:
	{essentialocl::BooleanLiteralExp}
	'BooleanLiteralExp'
	'{'
		('name' name=String0)?
		('booleanSymbol' booleanSymbol=Boolean)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

UnlimitedNaturalExp returns essentialocl::UnlimitedNaturalExp:
	{essentialocl::UnlimitedNaturalExp}
	'UnlimitedNaturalExp'
	'{'
		('name' name=String0)?
		('symbol' symbol=UnlimitedNatural)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

IfExp returns essentialocl::IfExp:
	'IfExp'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		'condition' condition=OclExpression
		'thenExpression' thenExpression=OclExpression
		'elseExpression' elseExpression=OclExpression
	'}';

LetExp returns essentialocl::LetExp:
	'LetExp'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		'in' in=OclExpression
		'variable' variable=Variable
	'}';

PropertyCallExp returns essentialocl::PropertyCallExp:
	{essentialocl::PropertyCallExp}
	'PropertyCallExp'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('referredProperty' referredProperty=[emof::Property|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('source' source=OclExpression)?
	'}';

VariableExp returns essentialocl::VariableExp:
	{essentialocl::VariableExp}
	'VariableExp'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('referredVariable' referredVariable=[essentialocl::Variable|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

TypeExp returns essentialocl::TypeExp:
	{essentialocl::TypeExp}
	'TypeExp'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('referredType' referredType=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

IteratorExp returns essentialocl::IteratorExp:
	'IteratorExp'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('source' source=OclExpression)?
		'body' body=OclExpression
		('iterator' '{' iterator+=Variable ( "," iterator+=Variable)* '}' )?
	'}';

StringLiteralExp returns essentialocl::StringLiteralExp:
	{essentialocl::StringLiteralExp}
	'StringLiteralExp'
	'{'
		('name' name=String0)?
		('stringSymbol' stringSymbol=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

IntegerLiteralExp returns essentialocl::IntegerLiteralExp:
	{essentialocl::IntegerLiteralExp}
	'IntegerLiteralExp'
	'{'
		('name' name=String0)?
		('integerSymbol' integerSymbol=Integer)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

OperationCallExp returns essentialocl::OperationCallExp:
	{essentialocl::OperationCallExp}
	'OperationCallExp'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('referredOperation' referredOperation=[emof::Operation|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('source' source=OclExpression)?
		('argument' '{' argument+=OclExpression ( "," argument+=OclExpression)* '}' )?
	'}';

RealLiteralExp returns essentialocl::RealLiteralExp:
	{essentialocl::RealLiteralExp}
	'RealLiteralExp'
	'{'
		('name' name=String0)?
		('realSymbol' realSymbol=Real)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

IterateExp returns essentialocl::IterateExp:
	'IterateExp'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('source' source=OclExpression)?
		'body' body=OclExpression
		('iterator' '{' iterator+=Variable ( "," iterator+=Variable)* '}' )?
		('result' result=Variable)?
	'}';

CollectionLiteralExp returns essentialocl::CollectionLiteralExp:
	{essentialocl::CollectionLiteralExp}
	'CollectionLiteralExp'
	'{'
		('name' name=String0)?
		('kind' kind=CollectionKind)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('part' '{' part+=CollectionLiteralPart ( "," part+=CollectionLiteralPart)* '}' )?
	'}';

TupleLiteralExp returns essentialocl::TupleLiteralExp:
	{essentialocl::TupleLiteralExp}
	'TupleLiteralExp'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('part' '{' part+=TupleLiteralPart ( "," part+=TupleLiteralPart)* '}' )?
	'}';

NullLiteralExp returns essentialocl::NullLiteralExp:
	{essentialocl::NullLiteralExp}
	'NullLiteralExp'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

InvalidLiteralExp returns essentialocl::InvalidLiteralExp:
	{essentialocl::InvalidLiteralExp}
	'InvalidLiteralExp'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

EnumLiteralExp returns essentialocl::EnumLiteralExp:
	{essentialocl::EnumLiteralExp}
	'EnumLiteralExp'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('referredEnumLiteral' referredEnumLiteral=[emof::EnumerationLiteral|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

Real returns emof::Real:
	'Real' /* TODO: implement this rule and an appropriate IValueConverter */;

enum CollectionKind returns essentialocl::CollectionKind:
				Set = 'Set' | OrderedSet = 'OrderedSet' | Bag = 'Bag' | Sequence = 'Sequence';

CollectionItem returns essentialocl::CollectionItem:
	'CollectionItem'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		'item' item=OclExpression
	'}';

CollectionRange returns essentialocl::CollectionRange:
	'CollectionRange'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		'first' first=OclExpression
		'last' last=OclExpression
	'}';

TupleLiteralPart returns essentialocl::TupleLiteralPart:
	'TupleLiteralPart'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('attribute' attribute=Property)?
		'value' value=OclExpression
	'}';

VarParameter_Impl returns qvtoperational::VarParameter:
	'VarParameter'
	'{'
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('name' name=String0)?
		('kind' kind=DirectionKind)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('bindParameter' bindParameter=[emof::Parameter|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('initExpression' initExpression=OclExpression)?
		'declarator' declarator=Declarator
	'}';

ImperativeOperation_Impl returns qvtoperational::ImperativeOperation:
	{qvtoperational::ImperativeOperation}
	'ImperativeOperation'
	'{'
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('raisedException' '(' raisedException+=[emof::Type|EString] ( "," raisedException+=[emof::Type|EString])* ')' )?
		('overridden' overridden=[qvtoperational::ImperativeOperation|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
		('body' body=OperationBody)?
	'}';

OperationBody_Impl returns qvtoperational::OperationBody:
	{qvtoperational::OperationBody}
	'OperationBody'
	'{'
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('content' '{' content+=ExpressionGO ( "," content+=ExpressionGO)* '}' )?
		('variable' '{' variable+=Variable ( "," variable+=Variable)* '}' )?
	'}';

HelperHeader returns qvtoperational::HelperHeader:
	'HelperHeader'
	'{'
		'helper_info' helper_info=HelperInfo
		'scope_identifier' scope_identifier=ScopedIdentifier
		'complete_signature' complete_signature=CompleteSignature
	'}';

enum DirectionKind returns qvtoperational::DirectionKind:
				in = 'in' | inout = 'inout' | out = 'out';

Declarator returns qvtoperational::Declarator:
	'Declarator'
	'{'
		'typespec' typespec=TypeSpec
		('init_part' init_part=InitPart)?
		('scoped_identifier' scoped_identifier=ScopedIdentifier)?
	'}';

MappingParameter returns qvtoperational::MappingParameter:
	'MappingParameter'
	'{'
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('name' name=String0)?
		('kind' kind=DirectionKind)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('bindParameter' bindParameter=[emof::Parameter|EString])?
		('refinedDomain' refinedDomain=[qvtrelation::RelationDomain|EString])?
		('extent' extent=[qvtoperational::ModelParameter|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('initExpression' initExpression=OclExpression)?
		'declarator' declarator=Declarator
	'}';

ModelParameter returns qvtoperational::ModelParameter:
	'ModelParameter'
	'{'
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('name' name=String0)?
		('kind' kind=DirectionKind)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('bindParameter' bindParameter=[emof::Parameter|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('initExpression' initExpression=OclExpression)?
		'declarator' declarator=Declarator
	'}';

TypeSpec returns qvtoperational::TypeSpec:
	'TypeSpec'
	'{'
		('extent_location' extent_location=EString)?
		'type_reference' type_reference=TypeReference
	'}';

InitPart returns qvtoperational::InitPart:
	'InitPart'
	'{'
		'init_op' init_op=EString
		'expression' expression=ExpressionGO
	'}';

TypeReference returns qvtoperational::TypeReference:
	{qvtoperational::TypeReference}
	'TypeReference'
	'{'
		('scoped_identifier' scoped_identifier=ScopedIdentifier)?
		('complex_type' complex_type=ComplexType)?
	'}';

ComplexType returns qvtoperational::ComplexType:
	{qvtoperational::ComplexType}
	'ComplexType'
	'{'
		('complex_type_key' complex_type_key=ComplexTypeKey)?
		('collection_key' collection_key=CollectionKey)?
		('typespec' '{' typespec+=TypeSpec ( "," typespec+=TypeSpec)* '}' )?
		('declarator_list' declarator_list=DeclaratorList)?
	'}';

enum ComplexTypeKey returns qvtoperational::ComplexTypeKey:
				Collection = 'Collection' | Set = 'Set' | OrderedSet = 'OrderedSet' | Sequence = 'Sequence' | Bag = 'Bag' | List = 'List' | Dict = 'Dict' | Tuple = 'Tuple';

enum CollectionKey returns qvtoperational::CollectionKey:
				Collection = 'Collection' | Set = 'Set' | OrderedSet = 'OrderedSet' | Sequence = 'Sequence' | Bag = 'Bag' | List = 'List';

DeclaratorList returns qvtoperational::DeclaratorList:
	{qvtoperational::DeclaratorList}
	'DeclaratorList'
	'{'
		('declarator' '{' declarator+=Declarator ( "," declarator+=Declarator)* '}' )?
	'}';

RelationDomain returns qvtrelation::RelationDomain:
	'RelationDomain'
	'{'
		('name' name=String0)?
		('isCheckable' isCheckable=Boolean)?
		('isEnforceable' isEnforceable=Boolean)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('typedModel' typedModel=[TypedModel|EString])?
		'rootVariable' rootVariable=[essentialocl::Variable|EString]
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('pattern' pattern=DomainPattern)?
		('defaultAssignment' '{' defaultAssignment+=RelationDomainAssignment ( "," defaultAssignment+=RelationDomainAssignment)* '}' )?
	'}';

TypedModel returns TypedModel:
	'TypedModel'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		'usedPackage' '(' usedPackage+=[emof::Package|EString] ( "," usedPackage+=[emof::Package|EString])* ')' 
		('dependsOn' '(' dependsOn+=[TypedModel|EString] ( "," dependsOn+=[TypedModel|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

DomainPattern returns qvtrelation::DomainPattern:
	{qvtrelation::DomainPattern}
	'DomainPattern'
	'{'
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('bindsTo' '(' bindsTo+=[essentialocl::Variable|EString] ( "," bindsTo+=[essentialocl::Variable|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('predicate' '{' predicate+=Predicate ( "," predicate+=Predicate)* '}' )?
		('templateExpression' templateExpression=TemplateExp)?
	'}';

RelationDomainAssignment returns qvtrelation::RelationDomainAssignment:
	'RelationDomainAssignment'
	'{'
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		'variable' variable=[essentialocl::Variable|EString]
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		'valueExp' valueExp=OclExpression
	'}';

Predicate returns Predicate:
	'Predicate'
	'{'
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		'conditionExpression' conditionExpression=OclExpression
	'}';

ObjectTemplateExp returns qvttemplate::ObjectTemplateExp:
	'ObjectTemplateExp'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('bindsTo' bindsTo=[essentialocl::Variable|EString])?
		'referredClass' referredClass=[emof::Class|EString]
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('where' where=OclExpression)?
		('part' '{' part+=PropertyTemplateItem ( "," part+=PropertyTemplateItem)* '}' )?
	'}';

CollectionTemplateExp returns qvttemplate::CollectionTemplateExp:
	'CollectionTemplateExp'
	'{'
		('name' name=String0)?
		('kind' kind=CollectionKind)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('type' type=[emof::Type|EString])?
		('bindsTo' bindsTo=[essentialocl::Variable|EString])?
		('referredCollectionType' referredCollectionType=[essentialocl::CollectionType|EString])?
		'rest' rest=[essentialocl::OclExpression|EString]
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('where' where=OclExpression)?
		'member' '{' member+=OclExpression ( "," member+=OclExpression)* '}' 
	'}';

PropertyTemplateItem returns qvttemplate::PropertyTemplateItem:
	'PropertyTemplateItem'
	'{'
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		'referredProperty' referredProperty=[emof::Property|EString]
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		'value' value=OclExpression
	'}';

BagType returns essentialocl::BagType:
	{essentialocl::BagType}
	'BagType'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('elementType' elementType=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

OrderedSetType returns essentialocl::OrderedSetType:
	{essentialocl::OrderedSetType}
	'OrderedSetType'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('elementType' elementType=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

SequenceType returns essentialocl::SequenceType:
	{essentialocl::SequenceType}
	'SequenceType'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('elementType' elementType=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

SetType returns essentialocl::SetType:
	{essentialocl::SetType}
	'SetType'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('elementType' elementType=[emof::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

MappingBody returns qvtoperational::MappingBody:
	{qvtoperational::MappingBody}
	'MappingBody'
	'{'
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('content' '{' content+=ExpressionGO ( "," content+=ExpressionGO)* '}' )?
		('variable' '{' variable+=Variable ( "," variable+=Variable)* '}' )?
		('initSection' '{' initSection+=ExpressionGO ( "," initSection+=ExpressionGO)* '}' )?
		('endSection' '{' endSection+=ExpressionGO ( "," endSection+=ExpressionGO)* '}' )?
		('population_section' population_section=PopulationSection)?
	'}';

ConstructorBody returns qvtoperational::ConstructorBody:
	{qvtoperational::ConstructorBody}
	'ConstructorBody'
	'{'
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('content' '{' content+=ExpressionGO ( "," content+=ExpressionGO)* '}' )?
		('variable' '{' variable+=Variable ( "," variable+=Variable)* '}' )?
	'}';

PopulationSection returns qvtoperational::PopulationSection:
	{qvtoperational::PopulationSection}
	'PopulationSection'
	'{'
		('expression_list' expression_list=ExpressionList)?
		('expression_block' expression_block=ExpressionBlock)?
	'}';

HelperInfo returns qvtoperational::HelperInfo:
	{qvtoperational::HelperInfo}
	'HelperInfo'
	'{'
		('qualifier' '{' qualifier+=GeneralQualifier ( "," qualifier+=GeneralQualifier)* '}' )?
		('helper_kind' helper_kind=HelperKind)?
	'}';

CompleteSignature returns qvtoperational::CompleteSignature:
	'CompleteSignature'
	'{'
		'simple_signature' simple_signature=SimpleSignature
		('param_list' param_list=ParamList)?
	'}';

enum GeneralQualifier returns qvtoperational::GeneralQualifier:
				blackbox = 'blackbox' | abstract = 'abstract' | static = 'static';

enum HelperKind returns qvtoperational::HelperKind:
				helper = 'helper' | query = 'query';

SimpleSignature returns qvtoperational::SimpleSignature:
	{qvtoperational::SimpleSignature}
	'SimpleSignature'
	'{'
		('param_list' param_list=ParamList)?
	'}';

ParamList returns qvtoperational::ParamList:
	{qvtoperational::ParamList}
	'ParamList'
	'{'
		('param' '{' param+=VarParameter ( "," param+=VarParameter)* '}' )?
	'}';

RelationalTransformation returns qvtrelation::RelationalTransformation:
	{qvtrelation::RelationalTransformation}
	'RelationalTransformation'
	'{'
		('name' name=String0)?
		('isAbstract' isAbstract=Boolean)?
		('uri' uri=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('superClass' '(' superClass+=[emof::Class|EString] ( "," superClass+=[emof::Class|EString])* ')' )?
		('extends' extends=[Transformation|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedAttribute' '{' ownedAttribute+=Property ( "," ownedAttribute+=Property)* '}' )?
		('ownedOperation' '{' ownedOperation+=Operation ( "," ownedOperation+=Operation)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('modelParameter' '{' modelParameter+=TypedModel ( "," modelParameter+=TypedModel)* '}' )?
		('rule' '{' rule+=Rule ( "," rule+=Rule)* '}' )?
		('ownedKey' '{' ownedKey+=Key ( "," ownedKey+=Key)* '}' )?
	'}';

Relation returns qvtrelation::Relation:
	{qvtrelation::Relation}
	'Relation'
	'{'
		('name' name=String0)?
		('isTopLevel' isTopLevel=Boolean)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('overrides' overrides=[Rule|EString])?
		('operationalImpl' '(' operationalImpl+=[qvtrelation::RelationImplementation|EString] ( "," operationalImpl+=[qvtrelation::RelationImplementation|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('domain' '{' domain+=Domain ( "," domain+=Domain)* '}' )?
		('variable' '{' variable+=Variable ( "," variable+=Variable)* '}' )?
		('when' when=Pattern)?
		('where' where=Pattern)?
	'}';

TransformationHeader returns qvtoperational::TransformationHeader:
	'TransformationHeader'
	name=EString
	'{'
		('qualifier' '{' qualifier+=GeneralQualifier ( "," qualifier+=GeneralQualifier)* '}' )?
		'transformation_signature' transformation_signature=SimpleSignature
		('transformation_usage_refine' transformation_usage_refine=TransformationUsageRefine)?
	'}';

Rule returns Rule:
	{Rule}
	'Rule'
	'{'
		('name' name=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('overrides' overrides=[Rule|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('domain' '{' domain+=Domain ( "," domain+=Domain)* '}' )?
	'}';

Transformation returns Transformation:
	{Transformation}
	'Transformation'
	'{'
		('name' name=String0)?
		('isAbstract' isAbstract=Boolean)?
		('uri' uri=String0)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('superClass' '(' superClass+=[emof::Class|EString] ( "," superClass+=[emof::Class|EString])* ')' )?
		('extends' extends=[Transformation|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedAttribute' '{' ownedAttribute+=Property ( "," ownedAttribute+=Property)* '}' )?
		('ownedOperation' '{' ownedOperation+=Operation ( "," ownedOperation+=Operation)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('modelParameter' '{' modelParameter+=TypedModel ( "," modelParameter+=TypedModel)* '}' )?
		('rule' '{' rule+=Rule ( "," rule+=Rule)* '}' )?
	'}';

Key returns qvtrelation::Key:
	'Key'
	'{'
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		'identifies' identifies=[emof::Class|EString]
		'part' '(' part+=[emof::Property|EString] ( "," part+=[emof::Property|EString])* ')' 
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

Domain returns Domain:
	{Domain}
	'Domain'
	'{'
		('name' name=String0)?
		('isCheckable' isCheckable=Boolean)?
		('isEnforceable' isEnforceable=Boolean)?
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('typedModel' typedModel=[TypedModel|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

RelationImplementation returns qvtrelation::RelationImplementation:
	'RelationImplementation'
	'{'
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('relation' relation=[qvtrelation::Relation|EString])?
		'impl' impl=[emof::Operation|EString]
		'inDirectionOf' inDirectionOf=[TypedModel|EString]
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

Pattern returns Pattern:
	{Pattern}
	'Pattern'
	'{'
		('tag' '(' tag+=[emof::Tag|EString] ( "," tag+=[emof::Tag|EString])* ')' )?
		('bindsTo' '(' bindsTo+=[essentialocl::Variable|EString] ( "," bindsTo+=[essentialocl::Variable|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('predicate' '{' predicate+=Predicate ( "," predicate+=Predicate)* '}' )?
	'}';

TransformationUsageRefine returns qvtoperational::TransformationUsageRefine:
	{qvtoperational::TransformationUsageRefine}
	'TransformationUsageRefine'
	'{'
		('module_usage' module_usage=ModuleUsageGO)?
		('transformation_refine' transformation_refine=ModuleRefGO)?
	'}';

ModuleUsageGO returns qvtoperational::ModuleUsageGO:
	{qvtoperational::ModuleUsageGO}
	'ModuleUsageGO'
	'{'
		('access_usage' access_usage=AccessUsage)?
		('extends_usage' extends_usage=ExtendsUsage)?
	'}';

ModuleRefGO returns qvtoperational::ModuleRefGO:
	'ModuleRefGO'
	'{'
		'scoped_identifier' scoped_identifier=ScopedIdentifier
		('simple_signature' simple_signature=SimpleSignature)?
	'}';

AccessUsage returns qvtoperational::AccessUsage:
	{qvtoperational::AccessUsage}
	'AccessUsage'
	'{'
		('module_kind' module_kind=ModuleKind)?
		('moduleref_list' '{' moduleref_list+=ModuleRefGO ( "," moduleref_list+=ModuleRefGO)* '}' )?
	'}';

ExtendsUsage returns qvtoperational::ExtendsUsage:
	{qvtoperational::ExtendsUsage}
	'ExtendsUsage'
	'{'
		('module_kind' module_kind=ModuleKind)?
		('moduleref_list' '{' moduleref_list+=ModuleRefGO ( "," moduleref_list+=ModuleRefGO)* '}' )?
	'}';

enum ModuleKind returns qvtoperational::ModuleKind:
				transformation = 'transformation' | library = 'library';

MappingFullHeader returns qvtoperational::MappingFullHeader:
	'MappingFullHeader'
	'{'
		'mapping_header' mapping_header=MappingHeader
		('when' when=ExpressionBlock)?
		('where' where=ExpressionBlock)?
	'}';

MappingHeader returns qvtoperational::MappingHeader:
	'MappingHeader'
	'{'
		('qualifier' '{' qualifier+=GeneralQualifier ( "," qualifier+=GeneralQualifier)* '}' )?
		('param_direction' param_direction=DirectionKind)?
		'scoped_identifier' scoped_identifier=ScopedIdentifier
		'complete_signature' complete_signature=CompleteSignature
		('mapping_extra' '{' mapping_extra+=MappingExtra ( "," mapping_extra+=MappingExtra)* '}' )?
	'}';

MappingExtra returns qvtoperational::MappingExtra:
	{qvtoperational::MappingExtra}
	'MappingExtra'
	'{'
		('mapping_extension' mapping_extension=MappingExtension)?
		('mapping_refinement' mapping_refinement=MappingRefinement)?
	'}';

MappingExtension returns qvtoperational::MappingExtension:
	'MappingExtension'
	'{'
		'mapping_extension_key' mapping_extension_key=MappingExtensionKey
		'scoped_identifier_list' scoped_identifier_list=ScopedIdentifierList
	'}';

MappingRefinement returns qvtoperational::MappingRefinement:
	'MappingRefinement'
	'{'
		'scoped_identifier' scoped_identifier=ScopedIdentifier
	'}';

enum MappingExtensionKey returns qvtoperational::MappingExtensionKey:
				inherits = 'inherits' | merges = 'merges' | disjuncts = 'disjuncts';

ScopedIdentifierList returns qvtoperational::ScopedIdentifierList:
	{qvtoperational::ScopedIdentifierList}
	'ScopedIdentifierList'
	'{'
		('scoped_identifier_list' '{' scoped_identifier_list+=ScopedIdentifier ( "," scoped_identifier_list+=ScopedIdentifier)* '}' )?
	'}';

ConstructorHeader returns qvtoperational::ConstructorHeader:
	'ConstructorHeader'
	'{'
		('qualifier' '{' qualifier+=GeneralQualifier ( "," qualifier+=GeneralQualifier)* '}' )?
		'scoped_identifier' scoped_identifier=ScopedIdentifier
		'simple_signature' simple_signature=SimpleSignature
	'}';

enum PropertyKey returns qvtoperational::PropertyKey:
				derived = 'derived' | literal = 'literal' | configuration = 'configuration' | property = 'property';

EntryHeader returns qvtoperational::EntryHeader:
	'EntryHeader'
	'{'
		'simple_signature' simple_signature=SimpleSignature
	'}';

LibraryHeader returns qvtoperational::LibraryHeader:
	{qvtoperational::LibraryHeader}
	'LibraryHeader'
	name=EString
	'{'
		('library_signature' library_signature=SimpleSignature)?
		('module_usage' module_usage=ModuleUsageGO)?
	'}';

MetaModelHeader returns qvtoperational::MetaModelHeader:
	'MetaModelHeader'
	'{'
		'scoped_identifier' scoped_identifier=ScopedIdentifier
	'}';

MetaModelElement returns qvtoperational::MetaModelElement:
	{qvtoperational::MetaModelElement}
	'MetaModelElement'
	'{'
		('classifier' classifier=ClassifierGO)?
		('enumeration' enumeration=EnumerationGO)?
		('tag' tag=TagGO)?
	'}';

EnumerationGO returns qvtoperational::EnumerationGO:
	{qvtoperational::EnumerationGO}
	'EnumerationGO'
	'{'
		('identifier' '{' identifier+=EString ( "," identifier+=EString)* '}' )?
		('enumeration_h' enumeration_h=EnumerationHeader)?
	'}';

EnumerationHeader returns qvtoperational::EnumerationHeader:
	'EnumerationHeader'
	'{'
		'identifier' identifier=EString
	'}';

ClassifierHeader returns qvtoperational::ClassifierHeader:
	'ClassifierHeader'
	'{'
		'classifier_info' classifier_info=ClassifierInfo
		'scoped_identifier' scoped_identifier=ScopedIdentifier
		('classifier_extension' classifier_extension=ClassifierExtension)?
	'}';

ClassifierFeatureList returns qvtoperational::ClassifierFeatureList:
	{qvtoperational::ClassifierFeatureList}
	'ClassifierFeatureList'
	'{'
		('classifier_feature' '{' classifier_feature+=ClassifierFeature ( "," classifier_feature+=ClassifierFeature)* '}' )?
	'}';

ClassifierInfo returns qvtoperational::ClassifierInfo:
	{qvtoperational::ClassifierInfo}
	'ClassifierInfo'
	'{'
		('qualifier' '{' qualifier+=GeneralQualifier ( "," qualifier+=GeneralQualifier)* '}' )?
	'}';

ClassifierExtension returns qvtoperational::ClassifierExtension:
	'ClassifierExtension'
	'{'
		'scoped_identifier_list' scoped_identifier_list=ScopedIdentifierList
	'}';

ClassifierFeature returns qvtoperational::ClassifierFeature:
	'ClassifierFeature'
	'{'
		('feature_qualifier' feature_qualifier=FeatureQualifier)?
		'declarator' declarator=Declarator
		('multiplicity' multiplicity=Multiplicity)?
		('opposite_property' opposite_property=OppositeProperty)?
		('complete_signature' complete_signature=CompleteSignature)?
		('tag' tag=TagGO)?
	'}';

FeatureQualifier returns qvtoperational::FeatureQualifier:
	{qvtoperational::FeatureQualifier}
	'FeatureQualifier'
	'{'
		('feature_key' '{' feature_key+=FeatureKey ( "," feature_key+=FeatureKey)* '}' )?
		('stereotype_qualifier' stereotype_qualifier=StereotypeQualifier)?
	'}';

Multiplicity returns qvtoperational::Multiplicity:
	'Multiplicity'
	'{'
		'multiplicity_range' multiplicity_range=EString
	'}';

OppositeProperty returns qvtoperational::OppositeProperty:
	{qvtoperational::OppositeProperty}
	'OppositeProperty'
	name=EString
	'{'
		('multiplicity' multiplicity=Multiplicity)?
	'}';

StereotypeQualifier returns qvtoperational::StereotypeQualifier:
	{qvtoperational::StereotypeQualifier}
	'StereotypeQualifier'
	'{'
		('identifier' '{' identifier+=EString ( "," identifier+=EString)* '}' )?
	'}';

enum FeatureKey returns qvtoperational::FeatureKey:
				composes = 'composes' | references = 'references' | readonly = 'readonly' | derived = 'derived' | static = 'static';

enum ImportKind returns qvtoperational::ImportKind:
				extension = 'extension' | access = 'access';

UnitRefGO returns qvtoperational::UnitRefGO:
	{qvtoperational::UnitRefGO}
	'UnitRefGO'
	'{'
		('identifier' '{' identifier+=EString ( "," identifier+=EString)* '}' )?
	'}';
