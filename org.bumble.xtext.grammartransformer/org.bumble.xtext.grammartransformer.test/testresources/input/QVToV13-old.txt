// automatically generated by Xtext
grammar org.omg.qvt13.myqvto.MyQvto with org.eclipse.xtext.common.Terminals

import "http://www.omg.org/spec/QVT/20151201/QVTOperational" 
import "http://www.omg.org/spec/QVT/20151201/EMOF" as EMOF
import "http://www.omg.org/spec/QVT/20151201/PrimitiveTypes" as PrimitiveTypes
import "http://www.omg.org/spec/QVT/20151201/EssentialOCL" as EssentialOCL
import "http://www.omg.org/spec/QVT/20151201/QVTRelation" as QVTRelation
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.omg.org/spec/QVT/20151201/QVTTemplate" as QVTTemplate
import "http://www.omg.org/spec/QVT/20151201/ImperativeOCL" as ImperativeOCL
import "http://www.omg.org/spec/QVT/20151201/QVTBase" as QVTBase

TopLevelGO returns TopLevelGO:
	{TopLevelGO}
	'TopLevelGO'
	'{'
		('unit_element' '{' unit_element+=Module ( "," unit_element+=Module)* '}' )?
		('moduleimport' '{' moduleimport+=ModuleImport ( "," moduleimport+=ModuleImport)* '}' )?
	'}';

Module returns Module:
	Module_Impl | Constructor | ContextualProperty | EntryOperation | Helper | Library | MappingOperation | ModelType | OperationalTransformation | TagGO | MetaModelGO | AccessDecl | TypeDef | ClassifierGO;




Type returns EMOF::Type:
	Class | DataType_Impl | Enumeration | PrimitiveType;







NamedElement returns EMOF::NamedElement:
	Class | DataType_Impl | Enumeration | EnumerationLiteral | Operation | Package | Parameter | PrimitiveType | Property;


OperationBody returns OperationBody:
	OperationBody_Impl | ConstructorBody | MappingBody;

VarParameter returns VarParameter:
	VarParameter_Impl | MappingParameter | ModelParameter;

ImperativeOperation returns ImperativeOperation:
	ImperativeOperation_Impl | Constructor | ContextualProperty | EntryOperation | Helper | MappingOperation | TagGO | AccessDecl | TypeDef | ClassifierGO;



Element returns EMOF::Element:
	Class | Comment | DataType_Impl | Enumeration | EnumerationLiteral | Factory | Operation | Package | Parameter | PrimitiveType | Property | Tag;

OclExpression returns EssentialOCL::OclExpression:
	BooleanLiteralExp | CollectionLiteralExp | EnumLiteralExp | IfExp | IntegerLiteralExp | InvalidLiteralExp | IterateExp | IteratorExp | LetExp | NavigationCallExp_Impl | NullLiteralExp | OperationCallExp | PropertyCallExp | RealLiteralExp | StringLiteralExp | TupleLiteralExp | TypeExp | UnlimitedNaturalExp | VariableExp;






























CollectionLiteralPart returns EssentialOCL::CollectionLiteralPart:
	CollectionItem | CollectionRange;









TemplateExp returns QVTTemplate::TemplateExp:
	CollectionTemplateExp | ObjectTemplateExp;

CollectionType returns EssentialOCL::CollectionType:
	CollectionType_Impl | BagType | OrderedSetType | SequenceType | SetType;































Module_Impl returns Module:
	{Module}
	'Module'
	'{'
		('name' name=String0)?
		('uri' uri=String0)?
		('configProperty' '(' configProperty+=[EMOF::Property|EString] ( "," configProperty+=[EMOF::Property|EString])* ')' )?
		('entry' entry=[EntryOperation|EString])?
		('usedModelType' '(' usedModelType+=[ModelType|EString] ( "," usedModelType+=[ModelType|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
	'}';

ModuleImport returns ModuleImport:
	'ModuleImport'
	'{'
		'kind' kind=ImportKind
		('identifier' '{' identifier+=EString ( "," identifier+=EString)* '}' )?
		('binding' '(' binding+=[ModelType|EString] ( "," binding+=[ModelType|EString])* ')' )?
		'importedModule' importedModule=[Module|EString]
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('unit' unit=UnitRefGO)?
	'}';

Comment returns EMOF::Comment:
	{EMOF::Comment}
	'Comment'
	'{'
		('body' body=String0)?
		('annotatedElement' '(' annotatedElement+=[EMOF::NamedElement|EString] ( "," annotatedElement+=[EMOF::NamedElement|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

String0 returns PrimitiveTypes::String:
	'String' /* TODO: implement this rule and an appropriate IValueConverter */;

Package returns EMOF::Package:
	{EMOF::Package}
	'Package'
	'{'
		('name' name=String0)?
		('uri' uri=String0)?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
	'}';

Property returns EMOF::Property:
	{EMOF::Property}
	'Property'
	'{'
		('name' name=String0)?
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('default' default=String0)?
		('isComposite' isComposite=Boolean)?
		('isDerived' isDerived=Boolean)?
		('isID' isID=Boolean)?
		('isReadOnly' isReadOnly=Boolean)?
		('type' type=[EMOF::Type|EString])?
		('opposite' opposite=[EMOF::Property|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

EntryOperation returns EntryOperation:
	'EntryOperation'
	'{'
		('name' name=String0)?
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('isBlackbox' isBlackbox=Boolean)?
		('uri' uri=String0)?
		('type' type=[EMOF::Type|EString])?
		('raisedException' '(' raisedException+=[EMOF::Type|EString] ( "," raisedException+=[EMOF::Type|EString])* ')' )?
		('overridden' overridden=[ImperativeOperation|EString])?
		('configProperty' '(' configProperty+=[EMOF::Property|EString] ( "," configProperty+=[EMOF::Property|EString])* ')' )?
		('entry' entry=[EntryOperation|EString])?
		('usedModelType' '(' usedModelType+=[ModelType|EString] ( "," usedModelType+=[ModelType|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('body' body=OperationBody)?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		'entry_header' entry_header=EntryHeader
		('expression_block' expression_block=ExpressionBlock)?
	'}';

Tag returns EMOF::Tag:
	{EMOF::Tag}
	'Tag'
	'{'
		('name' name=String0)?
		('value' value=String0)?
		('element' '(' element+=[EMOF::Element|EString] ( "," element+=[EMOF::Element|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

Variable returns EssentialOCL::Variable:
	{EssentialOCL::Variable}
	'Variable'
	'{'
		('name' name=String0)?
		('type' type=[EMOF::Type|EString])?
		('representedParameter' representedParameter=[EMOF::Parameter|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('initExpression' initExpression=OclExpression)?
	'}';

ModelType returns ModelType:
	'ModelType'
	'{'
		('name' name=String0)?
		('uri' uri=String0)?
		('conformanceKind' conformanceKind=String0)?
		('compliance_kind' compliance_kind=EString)?
		('configProperty' '(' configProperty+=[EMOF::Property|EString] ( "," configProperty+=[EMOF::Property|EString])* ')' )?
		('entry' entry=[EntryOperation|EString])?
		('usedModelType' '(' usedModelType+=[ModelType|EString] ( "," usedModelType+=[ModelType|EString])* ')' )?
		'metamodel' '(' metamodel+=[EMOF::Package|EString] ( "," metamodel+=[EMOF::Package|EString])* ')' 
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		('additionalCondition' '{' additionalCondition+=ExpressionGO ( "," additionalCondition+=ExpressionGO)* '}' )?
		('packageref_list' '{' packageref_list+=PackageRefGO ( "," packageref_list+=PackageRefGO)* '}' )?
		('modeltype_where' modeltype_where=ExpressionBlock)?
	'}';

Constructor returns Constructor:
	'Constructor'
	'{'
		('name' name=String0)?
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('isBlackbox' isBlackbox=Boolean)?
		('uri' uri=String0)?
		('type' type=[EMOF::Type|EString])?
		('raisedException' '(' raisedException+=[EMOF::Type|EString] ( "," raisedException+=[EMOF::Type|EString])* ')' )?
		('overridden' overridden=[ImperativeOperation|EString])?
		('configProperty' '(' configProperty+=[EMOF::Property|EString] ( "," configProperty+=[EMOF::Property|EString])* ')' )?
		('entry' entry=[EntryOperation|EString])?
		('usedModelType' '(' usedModelType+=[ModelType|EString] ( "," usedModelType+=[ModelType|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('body' body=OperationBody)?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		'constructor_header' constructor_header=ConstructorHeader
		('expression_block' expression_block=ExpressionBlock)?
	'}';

ContextualProperty returns ContextualProperty:
	'ContextualProperty'
	'{'
		('name' name=String0)?
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('isBlackbox' isBlackbox=Boolean)?
		('uri' uri=String0)?
		'property_key' '{' property_key+=PropertyKey ( "," property_key+=PropertyKey)* '}' 
		('type' type=[EMOF::Type|EString])?
		('raisedException' '(' raisedException+=[EMOF::Type|EString] ( "," raisedException+=[EMOF::Type|EString])* ')' )?
		('overridden' overridden=[ImperativeOperation|EString])?
		('configProperty' '(' configProperty+=[EMOF::Property|EString] ( "," configProperty+=[EMOF::Property|EString])* ')' )?
		('entry' entry=[EntryOperation|EString])?
		('usedModelType' '(' usedModelType+=[ModelType|EString] ( "," usedModelType+=[ModelType|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('body' body=OperationBody)?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		('initExpression' initExpression=ExpressionGO)?
		'declarator' declarator=Declarator
	'}';

Helper returns Helper:
	'Helper'
	'{'
		('name' name=String0)?
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('isBlackbox' isBlackbox=Boolean)?
		('uri' uri=String0)?
		('isQuery' isQuery=Boolean)?
		('type' type=[EMOF::Type|EString])?
		('raisedException' '(' raisedException+=[EMOF::Type|EString] ( "," raisedException+=[EMOF::Type|EString])* ')' )?
		('overridden' overridden=[ImperativeOperation|EString])?
		('configProperty' '(' configProperty+=[EMOF::Property|EString] ( "," configProperty+=[EMOF::Property|EString])* ')' )?
		('entry' entry=[EntryOperation|EString])?
		('usedModelType' '(' usedModelType+=[ModelType|EString] ( "," usedModelType+=[ModelType|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('body' body=OperationBody)?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		'helper_header' helper_header=HelperHeader
		('expression' expression=ExpressionGO)?
		('expression_block' expression_block=ExpressionBlock)?
	'}';

Library returns Library:
	'Library'
	'{'
		('name' name=String0)?
		('uri' uri=String0)?
		('configProperty' '(' configProperty+=[EMOF::Property|EString] ( "," configProperty+=[EMOF::Property|EString])* ')' )?
		('entry' entry=[EntryOperation|EString])?
		('usedModelType' '(' usedModelType+=[ModelType|EString] ( "," usedModelType+=[ModelType|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		'library_h' library_h=LibraryHeader
		('module_element' '{' module_element+=ImperativeOperation ( "," module_element+=ImperativeOperation)* '}' )?
	'}';

MappingOperation returns MappingOperation:
	'MappingOperation'
	'{'
		('name' name=String0)?
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('isBlackbox' isBlackbox=Boolean)?
		('uri' uri=String0)?
		('type' type=[EMOF::Type|EString])?
		('raisedException' '(' raisedException+=[EMOF::Type|EString] ( "," raisedException+=[EMOF::Type|EString])* ')' )?
		('overridden' overridden=[ImperativeOperation|EString])?
		('configProperty' '(' configProperty+=[EMOF::Property|EString] ( "," configProperty+=[EMOF::Property|EString])* ')' )?
		('entry' entry=[EntryOperation|EString])?
		('usedModelType' '(' usedModelType+=[ModelType|EString] ( "," usedModelType+=[ModelType|EString])* ')' )?
		('disjunct' '(' disjunct+=[MappingOperation|EString] ( "," disjunct+=[MappingOperation|EString])* ')' )?
		('inherited' '(' inherited+=[MappingOperation|EString] ( "," inherited+=[MappingOperation|EString])* ')' )?
		('merged' '(' merged+=[MappingOperation|EString] ( "," merged+=[MappingOperation|EString])* ')' )?
		('refinedRelation' refinedRelation=[QVTRelation::Relation|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('body' body=OperationBody)?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		('when' when=ExpressionGO)?
		('where' where=ExpressionGO)?
		'mapping_full_header' mapping_full_header=MappingFullHeader
		('mapping_body' mapping_body=MappingBody)?
	'}';

OperationalTransformation returns OperationalTransformation:
	'OperationalTransformation'
	'{'
		('name' name=String0)?
		('uri' uri=String0)?
		('configProperty' '(' configProperty+=[EMOF::Property|EString] ( "," configProperty+=[EMOF::Property|EString])* ')' )?
		('entry' entry=[EntryOperation|EString])?
		('usedModelType' '(' usedModelType+=[ModelType|EString] ( "," usedModelType+=[ModelType|EString])* ')' )?
		('intermediateClass' '(' intermediateClass+=[EMOF::Class|EString] ( "," intermediateClass+=[EMOF::Class|EString])* ')' )?
		('intermediateProperty' '(' intermediateProperty+=[EMOF::Property|EString] ( "," intermediateProperty+=[EMOF::Property|EString])* ')' )?
		('refined' refined=[QVTRelation::RelationalTransformation|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		('modelParameter' '{' modelParameter+=ModelParameter ( "," modelParameter+=ModelParameter)* '}' )?
		('relation' '{' relation+=Relation ( "," relation+=Relation)* '}' )?
		'transformation_h' transformation_h=TransformationHeader
		('module_element' '{' module_element+=ImperativeOperation ( "," module_element+=ImperativeOperation)* '}' )?
	'}';

TagGO returns TagGO:
	'TagGO'
	'{'
		('name' name=String0)?
		('uri' uri=String0)?
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('isBlackbox' isBlackbox=Boolean)?
		'tagid' tagid=EString
		('configProperty' '(' configProperty+=[EMOF::Property|EString] ( "," configProperty+=[EMOF::Property|EString])* ')' )?
		('entry' entry=[EntryOperation|EString])?
		('usedModelType' '(' usedModelType+=[ModelType|EString] ( "," usedModelType+=[ModelType|EString])* ')' )?
		('type' type=[EMOF::Type|EString])?
		('raisedException' '(' raisedException+=[EMOF::Type|EString] ( "," raisedException+=[EMOF::Type|EString])* ')' )?
		('overridden' overridden=[ImperativeOperation|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('body' body=OperationBody)?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
		'scoped_identifier' scoped_identifier=ScopedIdentifier
		('tagvalue' tagvalue=ExpressionGO)?
	'}';

MetaModelGO returns MetaModelGO:
	'MetaModelGO'
	'{'
		('name' name=String0)?
		('uri' uri=String0)?
		('configProperty' '(' configProperty+=[EMOF::Property|EString] ( "," configProperty+=[EMOF::Property|EString])* ')' )?
		('entry' entry=[EntryOperation|EString])?
		('usedModelType' '(' usedModelType+=[ModelType|EString] ( "," usedModelType+=[ModelType|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		'metamodel_h' metamodel_h=MetaModelHeader
		('metamodel_element' '{' metamodel_element+=MetaModelElement ( "," metamodel_element+=MetaModelElement)* '}' )?
	'}';

AccessDecl returns AccessDecl:
	'AccessDecl'
	'{'
		('name' name=String0)?
		('uri' uri=String0)?
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('isBlackbox' isBlackbox=Boolean)?
		('configProperty' '(' configProperty+=[EMOF::Property|EString] ( "," configProperty+=[EMOF::Property|EString])* ')' )?
		('entry' entry=[EntryOperation|EString])?
		('usedModelType' '(' usedModelType+=[ModelType|EString] ( "," usedModelType+=[ModelType|EString])* ')' )?
		('type' type=[EMOF::Type|EString])?
		('raisedException' '(' raisedException+=[EMOF::Type|EString] ( "," raisedException+=[EMOF::Type|EString])* ')' )?
		('overridden' overridden=[ImperativeOperation|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('body' body=OperationBody)?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
		'access_usage' access_usage=AccessUsage
	'}';

TypeDef returns TypeDef:
	'TypeDef'
	'{'
		('name' name=String0)?
		('uri' uri=String0)?
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('isBlackbox' isBlackbox=Boolean)?
		('configProperty' '(' configProperty+=[EMOF::Property|EString] ( "," configProperty+=[EMOF::Property|EString])* ')' )?
		('entry' entry=[EntryOperation|EString])?
		('usedModelType' '(' usedModelType+=[ModelType|EString] ( "," usedModelType+=[ModelType|EString])* ')' )?
		('type' type=[EMOF::Type|EString])?
		('raisedException' '(' raisedException+=[EMOF::Type|EString] ( "," raisedException+=[EMOF::Type|EString])* ')' )?
		('overridden' overridden=[ImperativeOperation|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('body' body=OperationBody)?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
		'typespec' typespec=TypeSpec
	'}';

ClassifierGO returns ClassifierGO:
	'ClassifierGO'
	'{'
		('name' name=String0)?
		('uri' uri=String0)?
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('isBlackbox' isBlackbox=Boolean)?
		('configProperty' '(' configProperty+=[EMOF::Property|EString] ( "," configProperty+=[EMOF::Property|EString])* ')' )?
		('entry' entry=[EntryOperation|EString])?
		('usedModelType' '(' usedModelType+=[ModelType|EString] ( "," usedModelType+=[ModelType|EString])* ')' )?
		('type' type=[EMOF::Type|EString])?
		('raisedException' '(' raisedException+=[EMOF::Type|EString] ( "," raisedException+=[EMOF::Type|EString])* ')' )?
		('overridden' overridden=[ImperativeOperation|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('moduleImport' '{' moduleImport+=ModuleImport ( "," moduleImport+=ModuleImport)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('ownedVariable' '{' ownedVariable+=Variable ( "," ownedVariable+=Variable)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('body' body=OperationBody)?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
		'classifier_h' classifier_h=ClassifierHeader
		('classifier_feature_list' classifier_feature_list=ClassifierFeatureList)?
	'}';

Class returns EMOF::Class:
	{EMOF::Class}
	'Class'
	'{'
		('name' name=String0)?
		('isAbstract' isAbstract=Boolean)?
		('superClass' '(' superClass+=[EMOF::Class|EString] ( "," superClass+=[EMOF::Class|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedAttribute' '{' ownedAttribute+=Property ( "," ownedAttribute+=Property)* '}' )?
		('ownedOperation' '{' ownedOperation+=Operation ( "," ownedOperation+=Operation)* '}' )?
	'}';

DataType_Impl returns EMOF::DataType:
	{EMOF::DataType}
	'DataType'
	'{'
		('name' name=String0)?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

Enumeration returns EMOF::Enumeration:
	{EMOF::Enumeration}
	'Enumeration'
	'{'
		('name' name=String0)?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedLiteral' '{' ownedLiteral+=EnumerationLiteral ( "," ownedLiteral+=EnumerationLiteral)* '}' )?
	'}';

EnumerationLiteral returns EMOF::EnumerationLiteral:
	{EMOF::EnumerationLiteral}
	'EnumerationLiteral'
	'{'
		('name' name=String0)?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

Operation returns EMOF::Operation:
	{EMOF::Operation}
	'Operation'
	'{'
		('name' name=String0)?
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('type' type=[EMOF::Type|EString])?
		('raisedException' '(' raisedException+=[EMOF::Type|EString] ( "," raisedException+=[EMOF::Type|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
	'}';

Parameter returns EMOF::Parameter:
	{EMOF::Parameter}
	'Parameter'
	'{'
		('name' name=String0)?
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('type' type=[EMOF::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

PrimitiveType returns EMOF::PrimitiveType:
	{EMOF::PrimitiveType}
	'PrimitiveType'
	'{'
		('name' name=String0)?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

Boolean returns PrimitiveTypes::Boolean:
	'Boolean' /* TODO: implement this rule and an appropriate IValueConverter */;

Integer returns PrimitiveTypes::Integer:
	'Integer' /* TODO: implement this rule and an appropriate IValueConverter */;

UnlimitedNatural returns PrimitiveTypes::UnlimitedNatural:
	'UnlimitedNatural' /* TODO: implement this rule and an appropriate IValueConverter */;

OperationBody_Impl returns OperationBody:
	{OperationBody}
	'OperationBody'
	'{'
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('content' '{' content+=ExpressionGO ( "," content+=ExpressionGO)* '}' )?
		('variable' '{' variable+=Variable ( "," variable+=Variable)* '}' )?
	'}';

VarParameter_Impl returns VarParameter:
	'VarParameter'
	'{'
		('name' name=String0)?
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('kind' kind=DirectionKind)?
		('type' type=[EMOF::Type|EString])?
		('representedParameter' representedParameter=[EMOF::Parameter|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('initExpression' initExpression=OclExpression)?
		'declarator' declarator=Declarator
	'}';

ImperativeOperation_Impl returns ImperativeOperation:
	{ImperativeOperation}
	'ImperativeOperation'
	'{'
		('name' name=String0)?
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('isBlackbox' isBlackbox=Boolean)?
		('type' type=[EMOF::Type|EString])?
		('raisedException' '(' raisedException+=[EMOF::Type|EString] ( "," raisedException+=[EMOF::Type|EString])* ')' )?
		('overridden' overridden=[ImperativeOperation|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedParameter' '{' ownedParameter+=Parameter ( "," ownedParameter+=Parameter)* '}' )?
		('body' body=OperationBody)?
		('context' context=VarParameter)?
		('result' '{' result+=VarParameter ( "," result+=VarParameter)* '}' )?
	'}';

EntryHeader returns EntryHeader:
	'EntryHeader'
	'{'
		'simple_signature' simple_signature=SimpleSignature
	'}';

ExpressionBlock returns ExpressionBlock:
	{ExpressionBlock}
	'ExpressionBlock'
	'{'
		('expression_list' expression_list=ExpressionList)?
	'}';

ExpressionGO returns ExpressionGO:
	{ExpressionGO}
	'ExpressionGO'
	'{'
		('dummyContent' '{' dummyContent+=EString ( "," dummyContent+=EString)* '}' )?
	'}';

ConstructorBody returns ConstructorBody:
	{ConstructorBody}
	'ConstructorBody'
	'{'
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('content' '{' content+=ExpressionGO ( "," content+=ExpressionGO)* '}' )?
		('variable' '{' variable+=Variable ( "," variable+=Variable)* '}' )?
	'}';

MappingBody returns MappingBody:
	{MappingBody}
	'MappingBody'
	'{'
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('content' '{' content+=ExpressionGO ( "," content+=ExpressionGO)* '}' )?
		('variable' '{' variable+=Variable ( "," variable+=Variable)* '}' )?
		('endSection' '{' endSection+=ExpressionGO ( "," endSection+=ExpressionGO)* '}' )?
		('initSection' '{' initSection+=ExpressionGO ( "," initSection+=ExpressionGO)* '}' )?
		('population_section' population_section=PopulationSection)?
	'}';

EString returns ecore::EString:
	STRING | ID;

PopulationSection returns PopulationSection:
	{PopulationSection}
	'PopulationSection'
	'{'
		('expression_list' expression_list=ExpressionList)?
		('expression_block' expression_block=ExpressionBlock)?
	'}';

ExpressionList returns ExpressionList:
	'ExpressionList'
	'{'
		'expression_semi_list' expression_semi_list=ExpressionSemiList
	'}';

ExpressionSemiList returns ExpressionSemiList:
	{ExpressionSemiList}
	'ExpressionSemiList'
	'{'
		('expression' '{' expression+=ExpressionGO ( "," expression+=ExpressionGO)* '}' )?
	'}';

enum DirectionKind returns DirectionKind:
				in = 'in' | inout = 'inout' | out = 'out';

Declarator returns Declarator:
	'Declarator'
	'{'
		'typespec' typespec=TypeSpec
		('init_part' init_part=InitPart)?
		('scoped_identifier' scoped_identifier=ScopedIdentifier)?
	'}';

MappingParameter returns MappingParameter:
	'MappingParameter'
	'{'
		('name' name=String0)?
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('kind' kind=DirectionKind)?
		('type' type=[EMOF::Type|EString])?
		('representedParameter' representedParameter=[EMOF::Parameter|EString])?
		('extent' extent=[ModelParameter|EString])?
		('referredDomain' referredDomain=[QVTRelation::RelationDomain|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('initExpression' initExpression=OclExpression)?
		'declarator' declarator=Declarator
	'}';

ModelParameter returns ModelParameter:
	'ModelParameter'
	'{'
		('name' name=String0)?
		('isOrdered' isOrdered=Boolean)?
		('isUnique' isUnique=Boolean)?
		('lower' lower=Integer)?
		('upper' upper=UnlimitedNatural)?
		('kind' kind=DirectionKind)?
		('type' type=[EMOF::Type|EString])?
		('representedParameter' representedParameter=[EMOF::Parameter|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('initExpression' initExpression=OclExpression)?
		'declarator' declarator=Declarator
	'}';

BooleanLiteralExp returns EssentialOCL::BooleanLiteralExp:
	{EssentialOCL::BooleanLiteralExp}
	'BooleanLiteralExp'
	'{'
		('name' name=String0)?
		('booleanSymbol' booleanSymbol=Boolean)?
		('type' type=[EMOF::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

CollectionLiteralExp returns EssentialOCL::CollectionLiteralExp:
	{EssentialOCL::CollectionLiteralExp}
	'CollectionLiteralExp'
	'{'
		('name' name=String0)?
		('kind' kind=CollectionKind)?
		('type' type=[EMOF::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('part' '{' part+=CollectionLiteralPart ( "," part+=CollectionLiteralPart)* '}' )?
	'}';

EnumLiteralExp returns EssentialOCL::EnumLiteralExp:
	{EssentialOCL::EnumLiteralExp}
	'EnumLiteralExp'
	'{'
		('name' name=String0)?
		('type' type=[EMOF::Type|EString])?
		('referredEnumLiteral' referredEnumLiteral=[EMOF::EnumerationLiteral|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

IfExp returns EssentialOCL::IfExp:
	'IfExp'
	'{'
		('name' name=String0)?
		('type' type=[EMOF::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		'condition' condition=OclExpression
		'elseExpression' elseExpression=OclExpression
		'thenExpression' thenExpression=OclExpression
	'}';

IntegerLiteralExp returns EssentialOCL::IntegerLiteralExp:
	{EssentialOCL::IntegerLiteralExp}
	'IntegerLiteralExp'
	'{'
		('name' name=String0)?
		('integerSymbol' integerSymbol=Integer)?
		('type' type=[EMOF::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

InvalidLiteralExp returns EssentialOCL::InvalidLiteralExp:
	{EssentialOCL::InvalidLiteralExp}
	'InvalidLiteralExp'
	'{'
		('name' name=String0)?
		('type' type=[EMOF::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

IterateExp returns EssentialOCL::IterateExp:
	'IterateExp'
	'{'
		('name' name=String0)?
		('type' type=[EMOF::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('source' source=OclExpression)?
		'body' body=OclExpression
		('iterator' '{' iterator+=Variable ( "," iterator+=Variable)* '}' )?
		('result' result=Variable)?
	'}';

IteratorExp returns EssentialOCL::IteratorExp:
	'IteratorExp'
	'{'
		('name' name=String0)?
		('type' type=[EMOF::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('source' source=OclExpression)?
		'body' body=OclExpression
		('iterator' '{' iterator+=Variable ( "," iterator+=Variable)* '}' )?
	'}';

LetExp returns EssentialOCL::LetExp:
	'LetExp'
	'{'
		('name' name=String0)?
		('type' type=[EMOF::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		'in' in=OclExpression
		'variable' variable=Variable
	'}';

NavigationCallExp_Impl returns EssentialOCL::NavigationCallExp:
	{EssentialOCL::NavigationCallExp}
	'NavigationCallExp'
	'{'
		('name' name=String0)?
		('type' type=[EMOF::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('source' source=OclExpression)?
	'}';

NullLiteralExp returns EssentialOCL::NullLiteralExp:
	{EssentialOCL::NullLiteralExp}
	'NullLiteralExp'
	'{'
		('name' name=String0)?
		('type' type=[EMOF::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

OperationCallExp returns EssentialOCL::OperationCallExp:
	{EssentialOCL::OperationCallExp}
	'OperationCallExp'
	'{'
		('name' name=String0)?
		('type' type=[EMOF::Type|EString])?
		('referredOperation' referredOperation=[EMOF::Operation|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('source' source=OclExpression)?
		('argument' '{' argument+=OclExpression ( "," argument+=OclExpression)* '}' )?
	'}';

PropertyCallExp returns EssentialOCL::PropertyCallExp:
	{EssentialOCL::PropertyCallExp}
	'PropertyCallExp'
	'{'
		('name' name=String0)?
		('type' type=[EMOF::Type|EString])?
		('referredProperty' referredProperty=[EMOF::Property|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('source' source=OclExpression)?
	'}';

RealLiteralExp returns EssentialOCL::RealLiteralExp:
	{EssentialOCL::RealLiteralExp}
	'RealLiteralExp'
	'{'
		('name' name=String0)?
		('realSymbol' realSymbol=Real)?
		('type' type=[EMOF::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

StringLiteralExp returns EssentialOCL::StringLiteralExp:
	{EssentialOCL::StringLiteralExp}
	'StringLiteralExp'
	'{'
		('name' name=String0)?
		('stringSymbol' stringSymbol=String0)?
		('type' type=[EMOF::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

TupleLiteralExp returns EssentialOCL::TupleLiteralExp:
	{EssentialOCL::TupleLiteralExp}
	'TupleLiteralExp'
	'{'
		('name' name=String0)?
		('type' type=[EMOF::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('part' '{' part+=TupleLiteralPart ( "," part+=TupleLiteralPart)* '}' )?
	'}';

TypeExp returns EssentialOCL::TypeExp:
	{EssentialOCL::TypeExp}
	'TypeExp'
	'{'
		('name' name=String0)?
		('type' type=[EMOF::Type|EString])?
		('referredType' referredType=[EMOF::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

UnlimitedNaturalExp returns EssentialOCL::UnlimitedNaturalExp:
	{EssentialOCL::UnlimitedNaturalExp}
	'UnlimitedNaturalExp'
	'{'
		('name' name=String0)?
		('symbol' symbol=UnlimitedNatural)?
		('type' type=[EMOF::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

VariableExp returns EssentialOCL::VariableExp:
	{EssentialOCL::VariableExp}
	'VariableExp'
	'{'
		('name' name=String0)?
		('type' type=[EMOF::Type|EString])?
		('referredVariable' referredVariable=[EssentialOCL::Variable|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

enum CollectionKind returns EssentialOCL::CollectionKind:
				Set = 'Set' | OrderedSet = 'OrderedSet' | Bag = 'Bag' | Sequence = 'Sequence' | Collection = 'Collection';

CollectionItem returns EssentialOCL::CollectionItem:
	'CollectionItem'
	'{'
		('name' name=String0)?
		('type' type=[EMOF::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		'item' item=OclExpression
	'}';

CollectionRange returns EssentialOCL::CollectionRange:
	'CollectionRange'
	'{'
		('name' name=String0)?
		('type' type=[EMOF::Type|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		'first' first=OclExpression
		'last' last=OclExpression
	'}';

Real returns PrimitiveTypes::Real:
	'Real' /* TODO: implement this rule and an appropriate IValueConverter */;

TupleLiteralPart returns EssentialOCL::TupleLiteralPart:
	'TupleLiteralPart'
	'{'
		('name' name=String0)?
		('type' type=[EMOF::Type|EString])?
		('attribute' attribute=[EMOF::Property|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		'value' value=OclExpression
	'}';

TypeSpec returns TypeSpec:
	'TypeSpec'
	'{'
		('extent_location' extent_location=EString)?
		'type_reference' type_reference=TypeReference
	'}';

InitPart returns InitPart:
	'InitPart'
	'{'
		'init_op' init_op=EString
		'expression' expression=ExpressionGO
	'}';

ScopedIdentifier returns ScopedIdentifier:
	{ScopedIdentifier}
	'ScopedIdentifier'
	'{'
		('identifier' '{' identifier+=EString ( "," identifier+=EString)* '}' )?
	'}';

TypeReference returns TypeReference:
	{TypeReference}
	'TypeReference'
	'{'
		('scoped_identifier' scoped_identifier=ScopedIdentifier)?
		('complex_type' complex_type=ComplexType)?
	'}';

ComplexType returns ComplexType:
	{ComplexType}
	'ComplexType'
	'{'
		('complex_type_key' complex_type_key=ComplexTypeKey)?
		('collection_key' collection_key=CollectionKey)?
		('typespec' '{' typespec+=TypeSpec ( "," typespec+=TypeSpec)* '}' )?
		('declarator_list' declarator_list=DeclaratorList)?
	'}';

enum ComplexTypeKey returns ComplexTypeKey:
				Collection = 'Collection' | Set = 'Set' | OrderedSet = 'OrderedSet' | Sequence = 'Sequence' | Bag = 'Bag' | List = 'List' | Dict = 'Dict' | Tuple = 'Tuple';

enum CollectionKey returns CollectionKey:
				Collection = 'Collection' | Set = 'Set' | OrderedSet = 'OrderedSet' | Sequence = 'Sequence' | Bag = 'Bag' | List = 'List';

DeclaratorList returns DeclaratorList:
	{DeclaratorList}
	'DeclaratorList'
	'{'
		('declarator' '{' declarator+=Declarator ( "," declarator+=Declarator)* '}' )?
	'}';

RelationDomain returns QVTRelation::RelationDomain:
	'RelationDomain'
	'{'
		('name' name=String0)?
		('isCheckable' isCheckable=Boolean)?
		('isEnforceable' isEnforceable=Boolean)?
		('typedModel' typedModel=[QVTBase::TypedModel|EString])?
		'rootVariable' '(' rootVariable+=[EssentialOCL::Variable|EString] ( "," rootVariable+=[EssentialOCL::Variable|EString])* ')' 
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('defaultAssignment' '{' defaultAssignment+=RelationDomainAssignment ( "," defaultAssignment+=RelationDomainAssignment)* '}' )?
		('pattern' '{' pattern+=DomainPattern ( "," pattern+=DomainPattern)* '}' )?
	'}';

TypedModel returns QVTBase::TypedModel:
	'TypedModel'
	'{'
		('name' name=String0)?
		('dependsOn' '(' dependsOn+=[QVTBase::TypedModel|EString] ( "," dependsOn+=[QVTBase::TypedModel|EString])* ')' )?
		'usedPackage' '(' usedPackage+=[EMOF::Package|EString] ( "," usedPackage+=[EMOF::Package|EString])* ')' 
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

RelationDomainAssignment returns QVTRelation::RelationDomainAssignment:
	'RelationDomainAssignment'
	'{'
		'variable' variable=[EssentialOCL::Variable|EString]
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		'valueExp' valueExp=OclExpression
	'}';

DomainPattern returns QVTRelation::DomainPattern:
	{QVTRelation::DomainPattern}
	'DomainPattern'
	'{'
		('bindsTo' '(' bindsTo+=[EssentialOCL::Variable|EString] ( "," bindsTo+=[EssentialOCL::Variable|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('predicate' '{' predicate+=Predicate ( "," predicate+=Predicate)* '}' )?
		('templateExpression' templateExpression=TemplateExp)?
	'}';

Predicate returns QVTBase::Predicate:
	'Predicate'
	'{'
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		'conditionExpression' conditionExpression=OclExpression
	'}';

CollectionTemplateExp returns QVTTemplate::CollectionTemplateExp:
	'CollectionTemplateExp'
	'{'
		('name' name=String0)?
		('type' type=[EMOF::Type|EString])?
		('bindsTo' bindsTo=[EssentialOCL::Variable|EString])?
		'referredCollectionType' referredCollectionType=[EssentialOCL::CollectionType|EString]
		('rest' rest=[EssentialOCL::Variable|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('where' where=OclExpression)?
		('member' '{' member+=OclExpression ( "," member+=OclExpression)* '}' )?
	'}';

ObjectTemplateExp returns QVTTemplate::ObjectTemplateExp:
	'ObjectTemplateExp'
	'{'
		('name' name=String0)?
		('type' type=[EMOF::Type|EString])?
		('bindsTo' bindsTo=[EssentialOCL::Variable|EString])?
		'referredClass' referredClass=[EMOF::Class|EString]
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('where' where=OclExpression)?
		('part' '{' part+=PropertyTemplateItem ( "," part+=PropertyTemplateItem)* '}' )?
	'}';

CollectionType_Impl returns EssentialOCL::CollectionType:
	'CollectionType'
	'{'
		('name' name=String0)?
		'elementType' elementType=[EMOF::Type|EString]
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

BagType returns EssentialOCL::BagType:
	'BagType'
	'{'
		('name' name=String0)?
		'elementType' elementType=[EMOF::Type|EString]
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

OrderedSetType returns EssentialOCL::OrderedSetType:
	'OrderedSetType'
	'{'
		('name' name=String0)?
		'elementType' elementType=[EMOF::Type|EString]
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

SequenceType returns EssentialOCL::SequenceType:
	'SequenceType'
	'{'
		('name' name=String0)?
		'elementType' elementType=[EMOF::Type|EString]
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

SetType returns EssentialOCL::SetType:
	'SetType'
	'{'
		('name' name=String0)?
		'elementType' elementType=[EMOF::Type|EString]
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

PropertyTemplateItem returns QVTTemplate::PropertyTemplateItem:
	'PropertyTemplateItem'
	'{'
		('isOpposite' isOpposite=Boolean)?
		'referredProperty' referredProperty=[EMOF::Property|EString]
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		'value' value=OclExpression
	'}';

SimpleSignature returns SimpleSignature:
	{SimpleSignature}
	'SimpleSignature'
	'{'
		('param_list' param_list=ParamList)?
	'}';

ParamList returns ParamList:
	{ParamList}
	'ParamList'
	'{'
		('param' '{' param+=VarParameter ( "," param+=VarParameter)* '}' )?
	'}';

Factory returns EMOF::Factory:
	'Factory'
	'{'
		'package' package=[EMOF::Package|EString]
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

PackageRefGO returns PackageRefGO:
	{PackageRefGO}
	'PackageRefGO'
	'{'
		('uri' uri=EString)?
		('scoped_identifier' scoped_identifier=ScopedIdentifier)?
	'}';

ConstructorHeader returns ConstructorHeader:
	'ConstructorHeader'
	'{'
		('qualifier' '{' qualifier+=GeneralQualifier ( "," qualifier+=GeneralQualifier)* '}' )?
		'scoped_identifier' scoped_identifier=ScopedIdentifier
		'simple_signature' simple_signature=SimpleSignature
	'}';

enum GeneralQualifier returns GeneralQualifier:
				blackbox = 'blackbox' | abstract = 'abstract' | static = 'static';

enum PropertyKey returns PropertyKey:
				derived = 'derived' | literal = 'literal' | configuration = 'configuration' | property = 'property';

HelperHeader returns HelperHeader:
	'HelperHeader'
	'{'
		'helper_info' helper_info=HelperInfo
		'scope_identifier' scope_identifier=ScopedIdentifier
		'complete_signature' complete_signature=CompleteSignature
	'}';

HelperInfo returns HelperInfo:
	{HelperInfo}
	'HelperInfo'
	'{'
		('qualifier' '{' qualifier+=GeneralQualifier ( "," qualifier+=GeneralQualifier)* '}' )?
		('helper_kind' helper_kind=HelperKind)?
	'}';

CompleteSignature returns CompleteSignature:
	'CompleteSignature'
	'{'
		'simple_signature' simple_signature=SimpleSignature
		('param_list' param_list=ParamList)?
	'}';

enum HelperKind returns HelperKind:
				helper = 'helper' | query = 'query';

LibraryHeader returns LibraryHeader:
	{LibraryHeader}
	'LibraryHeader'
	name=EString
	'{'
		('library_signature' library_signature=SimpleSignature)?
		('module_usage' module_usage=ModuleUsageGO)?
	'}';

ModuleUsageGO returns ModuleUsageGO:
	{ModuleUsageGO}
	'ModuleUsageGO'
	'{'
		('access_usage' access_usage=AccessUsage)?
		('extends_usage' extends_usage=ExtendsUsage)?
	'}';

AccessUsage returns AccessUsage:
	{AccessUsage}
	'AccessUsage'
	'{'
		('module_kind' module_kind=ModuleKind)?
		('moduleref_list' '{' moduleref_list+=ModuleRefGO ( "," moduleref_list+=ModuleRefGO)* '}' )?
	'}';

ExtendsUsage returns ExtendsUsage:
	{ExtendsUsage}
	'ExtendsUsage'
	'{'
		('module_kind' module_kind=ModuleKind)?
		('moduleref_list' '{' moduleref_list+=ModuleRefGO ( "," moduleref_list+=ModuleRefGO)* '}' )?
	'}';

enum ModuleKind returns ModuleKind:
				transformation = 'transformation' | library = 'library';

ModuleRefGO returns ModuleRefGO:
	'ModuleRefGO'
	'{'
		'scoped_identifier' scoped_identifier=ScopedIdentifier
		('simple_signature' simple_signature=SimpleSignature)?
	'}';

Relation returns QVTRelation::Relation:
	'Relation'
	'{'
		('name' name=String0)?
		'isAbstract' isAbstract=Boolean
		('isTopLevel' isTopLevel=Boolean)?
		('overrides' overrides=[QVTBase::Rule|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('domain' '{' domain+=Domain ( "," domain+=Domain)* '}' )?
		('operationalImpl' '{' operationalImpl+=RelationImplementation ( "," operationalImpl+=RelationImplementation)* '}' )?
		('variable' '{' variable+=Variable ( "," variable+=Variable)* '}' )?
		('when' when=Pattern)?
		('where' where=Pattern)?
	'}';

MappingFullHeader returns MappingFullHeader:
	'MappingFullHeader'
	'{'
		'mapping_header' mapping_header=MappingHeader
		('when' when=ExpressionBlock)?
		('where' where=ExpressionBlock)?
	'}';

RelationImplementation returns QVTRelation::RelationImplementation:
	'RelationImplementation'
	'{'
		'impl' impl=[EMOF::Operation|EString]
		'inDirectionOf' inDirectionOf=[QVTBase::TypedModel|EString]
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

Pattern returns QVTBase::Pattern:
	{QVTBase::Pattern}
	'Pattern'
	'{'
		('bindsTo' '(' bindsTo+=[EssentialOCL::Variable|EString] ( "," bindsTo+=[EssentialOCL::Variable|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('predicate' '{' predicate+=Predicate ( "," predicate+=Predicate)* '}' )?
	'}';

MappingHeader returns MappingHeader:
	'MappingHeader'
	'{'
		('qualifier' '{' qualifier+=GeneralQualifier ( "," qualifier+=GeneralQualifier)* '}' )?
		('param_direction' param_direction=DirectionKind)?
		'scoped_identifier' scoped_identifier=ScopedIdentifier
		'complete_signature' complete_signature=CompleteSignature
		('mapping_extra' '{' mapping_extra+=MappingExtra ( "," mapping_extra+=MappingExtra)* '}' )?
	'}';

MappingExtra returns MappingExtra:
	{MappingExtra}
	'MappingExtra'
	'{'
		('mapping_extension' mapping_extension=MappingExtension)?
		('mapping_refinement' mapping_refinement=MappingRefinement)?
	'}';

MappingExtension returns MappingExtension:
	'MappingExtension'
	'{'
		'mapping_extension_key' mapping_extension_key=MappingExtensionKey
		'scoped_identifier_list' scoped_identifier_list=ScopedIdentifierList
	'}';

MappingRefinement returns MappingRefinement:
	'MappingRefinement'
	'{'
		'scoped_identifier' scoped_identifier=ScopedIdentifier
	'}';

enum MappingExtensionKey returns MappingExtensionKey:
				inherits = 'inherits' | merges = 'merges' | disjuncts = 'disjuncts';

ScopedIdentifierList returns ScopedIdentifierList:
	{ScopedIdentifierList}
	'ScopedIdentifierList'
	'{'
		('scoped_identifier_list' '{' scoped_identifier_list+=ScopedIdentifier ( "," scoped_identifier_list+=ScopedIdentifier)* '}' )?
	'}';

RelationalTransformation returns QVTRelation::RelationalTransformation:
	{QVTRelation::RelationalTransformation}
	'RelationalTransformation'
	'{'
		('name' name=String0)?
		('isAbstract' isAbstract=Boolean)?
		('uri' uri=String0)?
		('superClass' '(' superClass+=[EMOF::Class|EString] ( "," superClass+=[EMOF::Class|EString])* ')' )?
		('extends' extends=[QVTBase::Transformation|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedAttribute' '{' ownedAttribute+=Property ( "," ownedAttribute+=Property)* '}' )?
		('ownedOperation' '{' ownedOperation+=Operation ( "," ownedOperation+=Operation)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('modelParameter' '{' modelParameter+=TypedModel ( "," modelParameter+=TypedModel)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('rule' '{' rule+=Rule ( "," rule+=Rule)* '}' )?
		('ownedKey' '{' ownedKey+=Key ( "," ownedKey+=Key)* '}' )?
	'}';

TransformationHeader returns TransformationHeader:
	'TransformationHeader'
	name=EString
	'{'
		('qualifier' '{' qualifier+=GeneralQualifier ( "," qualifier+=GeneralQualifier)* '}' )?
		'transformation_signature' transformation_signature=SimpleSignature
		('transformation_usage_refine' transformation_usage_refine=TransformationUsageRefine)?
	'}';

Transformation returns QVTBase::Transformation:
	{QVTBase::Transformation}
	'Transformation'
	'{'
		('name' name=String0)?
		('isAbstract' isAbstract=Boolean)?
		('uri' uri=String0)?
		('superClass' '(' superClass+=[EMOF::Class|EString] ( "," superClass+=[EMOF::Class|EString])* ')' )?
		('extends' extends=[QVTBase::Transformation|EString])?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
		('ownedAttribute' '{' ownedAttribute+=Property ( "," ownedAttribute+=Property)* '}' )?
		('ownedOperation' '{' ownedOperation+=Operation ( "," ownedOperation+=Operation)* '}' )?
		('nestedPackage' '{' nestedPackage+=Package ( "," nestedPackage+=Package)* '}' )?
		('ownedType' '{' ownedType+=Type ( "," ownedType+=Type)* '}' )?
		('modelParameter' '{' modelParameter+=TypedModel ( "," modelParameter+=TypedModel)* '}' )?
		('ownedTag' '{' ownedTag+=Tag ( "," ownedTag+=Tag)* '}' )?
		('rule' '{' rule+=Rule ( "," rule+=Rule)* '}' )?
	'}';

Key returns QVTRelation::Key:
	'Key'
	'{'
		'identifies' identifies=[EMOF::Class|EString]
		('oppositePart' '(' oppositePart+=[EMOF::Property|EString] ( "," oppositePart+=[EMOF::Property|EString])* ')' )?
		('part' '(' part+=[EMOF::Property|EString] ( "," part+=[EMOF::Property|EString])* ')' )?
		('ownedComment' '{' ownedComment+=Comment ( "," ownedComment+=Comment)* '}' )?
	'}';

TransformationUsageRefine returns TransformationUsageRefine:
	{TransformationUsageRefine}
	'TransformationUsageRefine'
	'{'
		('module_usage' module_usage=ModuleUsageGO)?
		('transformation_refine' transformation_refine=ModuleRefGO)?
	'}';

MetaModelHeader returns MetaModelHeader:
	'MetaModelHeader'
	'{'
		'scoped_identifier' scoped_identifier=ScopedIdentifier
	'}';

MetaModelElement returns MetaModelElement:
	{MetaModelElement}
	'MetaModelElement'
	'{'
		('classifier' classifier=ClassifierGO)?
		('enumeration' enumeration=EnumerationGO)?
		('tag' tag=TagGO)?
	'}';

EnumerationGO returns EnumerationGO:
	{EnumerationGO}
	'EnumerationGO'
	'{'
		('identifier' '{' identifier+=EString ( "," identifier+=EString)* '}' )?
		('enumeration_h' enumeration_h=EnumerationHeader)?
	'}';

EnumerationHeader returns EnumerationHeader:
	'EnumerationHeader'
	'{'
		'identifier' identifier=EString
	'}';

ClassifierHeader returns ClassifierHeader:
	'ClassifierHeader'
	'{'
		'classifier_info' classifier_info=ClassifierInfo
		'scoped_identifier' scoped_identifier=ScopedIdentifier
		('classifier_extension' classifier_extension=ClassifierExtension)?
	'}';

ClassifierFeatureList returns ClassifierFeatureList:
	{ClassifierFeatureList}
	'ClassifierFeatureList'
	'{'
		('classifier_feature' '{' classifier_feature+=ClassifierFeature ( "," classifier_feature+=ClassifierFeature)* '}' )?
	'}';

ClassifierInfo returns ClassifierInfo:
	{ClassifierInfo}
	'ClassifierInfo'
	'{'
		('qualifier' '{' qualifier+=GeneralQualifier ( "," qualifier+=GeneralQualifier)* '}' )?
	'}';

ClassifierExtension returns ClassifierExtension:
	'ClassifierExtension'
	'{'
		'scoped_identifier_list' scoped_identifier_list=ScopedIdentifierList
	'}';

ClassifierFeature returns ClassifierFeature:
	'ClassifierFeature'
	'{'
		('feature_qualifier' feature_qualifier=FeatureQualifier)?
		'declarator' declarator=Declarator
		('multiplicity' multiplicity=Multiplicity)?
		('opposite_property' opposite_property=OppositeProperty)?
		('complete_signature' complete_signature=CompleteSignature)?
		('tag' tag=TagGO)?
	'}';

FeatureQualifier returns FeatureQualifier:
	{FeatureQualifier}
	'FeatureQualifier'
	'{'
		('feature_key' '{' feature_key+=FeatureKey ( "," feature_key+=FeatureKey)* '}' )?
		('stereotype_qualifier' stereotype_qualifier=StereotypeQualifier)?
	'}';

Multiplicity returns Multiplicity:
	'Multiplicity'
	'{'
		'multiplicity_range' multiplicity_range=EString
	'}';

OppositeProperty returns OppositeProperty:
	{OppositeProperty}
	'OppositeProperty'
	name=EString
	'{'
		('multiplicity' multiplicity=Multiplicity)?
	'}';

StereotypeQualifier returns StereotypeQualifier:
	{StereotypeQualifier}
	'StereotypeQualifier'
	'{'
		('identifier' '{' identifier+=EString ( "," identifier+=EString)* '}' )?
	'}';

enum FeatureKey returns FeatureKey:
				composes = 'composes' | references = 'references' | readonly = 'readonly' | derived = 'derived' | static = 'static';

enum ImportKind returns ImportKind:
				extension = 'extension' | access = 'access';

UnitRefGO returns UnitRefGO:
	{UnitRefGO}
	'UnitRefGO'
	'{'
		('identifier' '{' identifier+=EString ( "," identifier+=EString)* '}' )?
	'}';
