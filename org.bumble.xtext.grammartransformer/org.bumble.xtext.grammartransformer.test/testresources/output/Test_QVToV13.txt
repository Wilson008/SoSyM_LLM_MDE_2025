// automatically generated by Xtext
grammar org.omg.qvt13.myqvto.MyQvto with org.eclipse.xtext.common.Terminals

import "http://www.omg.org/spec/QVT/20151201/QVTOperational" 
import "http://www.omg.org/spec/QVT/20151201/EMOF" as EMOF
import "http://www.omg.org/spec/QVT/20151201/PrimitiveTypes" as PrimitiveTypes
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

TopLevelGO returns TopLevelGO:
    {TopLevelGO}
    
    
          (moduleimport+=ModuleImport)*  
          (unit_element+=Module)*  
    ;

Module returns Module:
  Constructor | ContextualProperty | EntryOperation | Helper | Library | MappingOperation | ModelType | OperationalTransformation | TagGO | MetaModelGO | AccessDecl | TypeDef | ClassifierGO;

ImperativeOperation returns ImperativeOperation:
  Constructor | ContextualProperty | EntryOperation | Helper | MappingOperation | TagGO | AccessDecl | TypeDef | ClassifierGO;

ModuleImport returns ModuleImport:
    
    
          'from' unit=UnitRefGO 'import' (identifier+=ID ( "," identifier+=ID)*  | '*') ';' |
        'import' unit=UnitRefGO ';'
    ;

EntryOperation returns EntryOperation:
    
         entry_header=EntryHeader ( ';' |
    
         expression_block=ExpressionBlock (';')?)
    ;

ExpressionGO returns ExpressionGO:
    {ExpressionGO}
    
    
          (dummyContent+=EString)*  
    ;

ModelType returns ModelType:
    'modeltype'
    
         name=ID
        ( compliance_kind=STRING)?
        'uses'  packageref_list+=PackageRefGO ( "," packageref_list+=PackageRefGO)*  
        ( 'where'  modeltype_where=ExpressionBlock)?
     ';' ;

Constructor returns Constructor:
    
         constructor_header=ConstructorHeader ( ';' |
    
         expression_block=ExpressionBlock (';')?)
    ;

ContextualProperty returns ContextualProperty:
    ('intermediate')?
    
          (property_key+=PropertyKey)+  
         declarator=Declarator
     ';' ;

Helper returns Helper:
    
    
         helper_header=HelperHeader ( ';' |
         '=' expression=ExpressionGO ';' |
         expression_block=ExpressionBlock (';')?)
    ;

Library returns Library:
    
         library_h=LibraryHeader ( ';' |
         '{' (module_element+=ImperativeOperation)* '}'  (';')?)
    ;

MappingOperation returns MappingOperation:
    
         mapping_full_header=MappingFullHeader ( ';' |
    
         '{'mapping_body=MappingBody'}' (';')?)
    ;

OperationalTransformation returns OperationalTransformation:
    
         transformation_h=TransformationHeader ( ';' |
         '{' (module_element+=ImperativeOperation)* '}'  (';')? )
    ;

TagGO returns TagGO:
    'tag'
    
         tagid=STRING
         scoped_identifier=ScopedIdentifier
        ('=' tagvalue=ExpressionGO)?
     ';' ;

MetaModelGO returns MetaModelGO:
    
         metamodel_h=MetaModelHeader ( ';' |
         '{' (metamodel_element+=MetaModelElement)* '}'  (';')?)
    ;

AccessDecl returns AccessDecl:
    
    
         access_usage=AccessUsage ';'
    ;

TypeDef returns TypeDef:
    'typedef'
    
         name=ID
         '=' typespec=TypeSpec
     ';' ;

ClassifierGO returns ClassifierGO:
    
         classifier_h=ClassifierHeader ( ';' |
        '{'( classifier_feature_list=ClassifierFeatureList)?'}' (';')?)
    ;

VarParameter returns VarParameter:
    
    
        ( kind=DirectionKind)?
         declarator=Declarator
    ;

EntryHeader returns EntryHeader:
    
    
        'main' simple_signature=SimpleSignature
    ;

ExpressionBlock returns ExpressionBlock:
    {ExpressionBlock}
    
    '{'
        ( expression_list=ExpressionList)?
    '}';

MappingBody returns MappingBody:
    {MappingBody}
    
    
          ('init' '{'(initSection+=ExpressionGO ( ";" initSection+=ExpressionGO)*   (';')?)?'}')?
        ( population_section=PopulationSection)?
          ('end' '{'(endSection+=ExpressionGO ( ";" endSection+=ExpressionGO)*   (';')?)?'}')?
    ;

PopulationSection returns PopulationSection:
    {PopulationSection}
    
    
         expression_list=ExpressionList |
         'population' expression_block=ExpressionBlock
    ;

ExpressionList returns ExpressionList:
    
    
         expression_semi_list=ExpressionSemiList (';')?
    ;

ExpressionSemiList returns ExpressionSemiList:
    {ExpressionSemiList}
    
    
          expression+=ExpressionGO ( "," expression+=ExpressionGO)*  
    ;

EString returns ecore::EString:
    STRING | ID;

enum DirectionKind returns DirectionKind:
                in = 'in' | inout = 'inout' | out = 'out';

Declarator returns Declarator:
    
    
         typespec=TypeSpec
        ( init_part=InitPart)?|
         scoped_identifier=ScopedIdentifier ':' typespec=TypeSpec ( init_part=InitPart)?
    ;

TypeSpec returns TypeSpec:
    
    
         type_reference=TypeReference
        ('@' extent_location=ID)?
    ;

InitPart returns InitPart:
    
    
         init_op=('=' | ':=' | '::=')
         expression=ExpressionGO
    ;

ScopedIdentifier returns ScopedIdentifier:
    {ScopedIdentifier}
    
    
          identifier+=ID ( "::" identifier+=ID)*  
    ;

TypeReference returns TypeReference:
    {TypeReference}
    
    
         scoped_identifier=ScopedIdentifier |
         complex_type=ComplexType
    ;

ComplexType returns ComplexType:
    {ComplexType}
    
    
         complex_type_key=ComplexTypeKey |
         collection_key=CollectionKey '(' typespec+=TypeSpec ')' |
          'Dict' '(' typespec+=TypeSpec','typespec+=TypeSpec   ')' |
         'Tuple' '('declarator_list=DeclaratorList')'
    ;

enum ComplexTypeKey returns ComplexTypeKey:
                Collection = 'Collection' | Set = 'Set' | OrderedSet = 'OrderedSet' | Sequence = 'Sequence' | Bag = 'Bag' | List = 'List' | Dict = 'Dict' | Tuple = 'Tuple';

enum CollectionKey returns CollectionKey:
                Collection = 'Collection' | Set = 'Set' | OrderedSet = 'OrderedSet' | Sequence = 'Sequence' | Bag = 'Bag' | List = 'List';

DeclaratorList returns DeclaratorList:
    {DeclaratorList}
    
    
          declarator+=Declarator ( "," declarator+=Declarator)*  
    ;

SimpleSignature returns SimpleSignature:
    {SimpleSignature}
    
    '('
        ( param_list=ParamList)?
    ')';

ParamList returns ParamList:
    {ParamList}
    
    
          param+=VarParameter ( "," param+=VarParameter)*  
    ;

PackageRefGO returns PackageRefGO:
    {PackageRefGO}
    
    
         (scoped_identifier=ScopedIdentifier
        ( '(' uri=STRING ')' )? | uri=STRING)
    ;

ConstructorHeader returns ConstructorHeader:
          (qualifier+=GeneralQualifier)*  
    'constructor'
    
         scoped_identifier=ScopedIdentifier
         simple_signature=SimpleSignature
    ;

enum GeneralQualifier returns GeneralQualifier:
                blackbox = 'blackbox' | abstract = 'abstract' | static = 'static';

enum PropertyKey returns PropertyKey:
                derived = 'derived' | literal = 'literal' | configuration = 'configuration' | property = 'property';

HelperHeader returns HelperHeader:
    
    
         helper_info=HelperInfo
         scope_identifier=ScopedIdentifier
         complete_signature=CompleteSignature
    ;

HelperInfo returns HelperInfo:
    {HelperInfo}
    
    
          (qualifier+=GeneralQualifier)*  
         helper_kind=HelperKind
    ;

CompleteSignature returns CompleteSignature:
    
    
         simple_signature=SimpleSignature
        (':' param_list=ParamList)?
    ;

enum HelperKind returns HelperKind:
                helper = 'helper' | query = 'query';

LibraryHeader returns LibraryHeader:
    {LibraryHeader}
    'library'
    name=ID
    
        ( library_signature=SimpleSignature)?
        ( module_usage=ModuleUsageGO)?
    ;

ModuleUsageGO returns ModuleUsageGO:
    {ModuleUsageGO}
    
    
         access_usage=AccessUsage |
         extends_usage=ExtendsUsage
    ;

AccessUsage returns AccessUsage:
    {AccessUsage}
    'access'
    
        ( module_kind=ModuleKind)?
          moduleref_list+=ModuleRefGO ( "," moduleref_list+=ModuleRefGO)*  
    ;

ExtendsUsage returns ExtendsUsage:
    {ExtendsUsage}
    'extends'
    
        ( module_kind=ModuleKind)?
          moduleref_list+=ModuleRefGO ( "," moduleref_list+=ModuleRefGO)*  
    ;

enum ModuleKind returns ModuleKind:
                transformation = 'transformation' | library = 'library';

ModuleRefGO returns ModuleRefGO:
    
    
         scoped_identifier=ScopedIdentifier
        ( simple_signature=SimpleSignature)?
    ;

MappingFullHeader returns MappingFullHeader:
    
    
         mapping_header=MappingHeader
        ('when' when=ExpressionBlock)?
        ('where' where=ExpressionBlock)?
    ;

MappingHeader returns MappingHeader:
          (qualifier+=GeneralQualifier)*  
    'mapping'
    
         (param_direction=DirectionKind)?
         scoped_identifier=ScopedIdentifier
         complete_signature=CompleteSignature
          (mapping_extra+=MappingExtra)*  
    ;

MappingExtra returns MappingExtra:
    {MappingExtra}
    
    
         mapping_extension=MappingExtension |
         mapping_refinement=MappingRefinement
    ;

MappingExtension returns MappingExtension:
    
    
         mapping_extension_key=MappingExtensionKey
         scoped_identifier_list=ScopedIdentifierList
    ;

MappingRefinement returns MappingRefinement:
    
    
        'refines' scoped_identifier=ScopedIdentifier
    ;

enum MappingExtensionKey returns MappingExtensionKey:
                inherits = 'inherits' | merges = 'merges' | disjuncts = 'disjuncts';

ScopedIdentifierList returns ScopedIdentifierList:
    {ScopedIdentifierList}
    
    
          scoped_identifier_list+=ScopedIdentifier ( "," scoped_identifier_list+=ScopedIdentifier)*  
    ;

TransformationHeader returns TransformationHeader:
          (qualifier+=GeneralQualifier)*  
    'transformation'
    name=ID
    
         transformation_signature=SimpleSignature
        ( transformation_usage_refine=TransformationUsageRefine)?
    ;

TransformationUsageRefine returns TransformationUsageRefine:
    {TransformationUsageRefine}
    
    
         module_usage=ModuleUsageGO |
        'refines'  transformation_refine=ModuleRefGO
    ;

MetaModelHeader returns MetaModelHeader:
    ('metamodel' | 'package')
    
         scoped_identifier=ScopedIdentifier
    ;

MetaModelElement returns MetaModelElement:
    {MetaModelElement}
    
    
         classifier=ClassifierGO |
         enumeration=EnumerationGO |
         tag=TagGO
    ;

EnumerationGO returns EnumerationGO:
    {EnumerationGO}
    
         enumeration_h=EnumerationHeader ( ';' |
         '{' identifier+=EString ( "," identifier+=EString)* '}'  (';')?)
    ;

EnumerationHeader returns EnumerationHeader:
    'enum'
    
         identifier=ID
    ;

ClassifierHeader returns ClassifierHeader:
    
    
         classifier_info=ClassifierInfo
         scoped_identifier=ScopedIdentifier
        ( classifier_extension=ClassifierExtension)?
    ;

ClassifierFeatureList returns ClassifierFeatureList:
    {ClassifierFeatureList}
    
    
          classifier_feature+=ClassifierFeature ( ";" classifier_feature+=ClassifierFeature)*   (';')?
    ;

ClassifierInfo returns ClassifierInfo:
    {ClassifierInfo}
    'datatype' | 'primitive' | 'exception' | ('intermediate')?
    
          (qualifier+=GeneralQualifier)*   'class'
    ;

ClassifierExtension returns ClassifierExtension:
    
    
        'extends' scoped_identifier_list=ScopedIdentifierList
    ;

ClassifierFeature returns ClassifierFeature:
    
    
        (( feature_qualifier=FeatureQualifier)?
         declarator=Declarator
        (( multiplicity=Multiplicity)?
        ( opposite_property=OppositeProperty)?|
         complete_signature=CompleteSignature))|
         tag=TagGO
    ;

FeatureQualifier returns FeatureQualifier:
    {FeatureQualifier}
    
    
        ( stereotype_qualifier=StereotypeQualifier)?
          (feature_key+=FeatureKey)*  
    ;

Multiplicity returns Multiplicity:
    
    '['
         multiplicity_range=MULTIPLICITYRANGE
    ']';

OppositeProperty returns OppositeProperty:
    {OppositeProperty}
    'opposites'
    ('~')? name=ID
    
        ( multiplicity=Multiplicity)?
    ;

StereotypeQualifier returns StereotypeQualifier:
    {StereotypeQualifier}
    
    
          '<<' identifier+=ID ( "," identifier+=ID)*   '>>'
    ;

enum FeatureKey returns FeatureKey:
                composes = 'composes' | references = 'references' | readonly = 'readonly' | derived = 'derived' | static = 'static';

UnitRefGO returns UnitRefGO:
    {UnitRefGO}
    
    
          identifier+=ID ( "." identifier+=ID)*  
    ;

terminal MULTIPLICITYRANGE:
    INT | '*' | INT '...' INT | INT '...' '*';

