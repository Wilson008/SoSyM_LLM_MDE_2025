// automatically generated by Xtext
grammar org.xtext.example.myspectra.MySpectra with org.eclipse.xtext.common.Terminals
import "http://smlab.cs.tau.ac.il/syntech/Spectra"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore


Model returns Model:
    {Model}
          (imports+=Import)*  
    ('module' | 'spec')
    name=ID
    
          (elements+=Decl)+  
    ;

Decl returns Decl:
  WeightDef | Var | TypeDef | Define | DefineRegExp | Counter | Monitor | Pattern | Predicate | LTLGar | LTLAsm | EXGar;

TemporalExpression returns TemporalExpression:
    QuantifierExpr;

RegExp returns RegExp:
    BinaryRegExp;

PredicateOrPatternReferrable returns PredicateOrPatternReferrable:
  Pattern | Predicate;

Referrable returns Referrable:
  VarDecl | TypeConstant | DefineDecl | DefineRegExpDecl | PatternParam | TypedParam | Counter | Monitor | DomainVarDecl;

Import returns Import:
    {Import}
    
    
        'import' importURI=STRING
    ;

WeightDef returns WeightDef:
    {WeightDef}
    'weight'
    (name=ID ':')?
    
         negative=('-')?
         value=INT
         definition=TemporalInExpr
     ';' ;

Var returns Var:
    {Var}
    
    
         kind=VarOwner
         var=VarDecl
    ;

TypeDef returns TypeDef:
    {TypeDef}
    'type'
    name=ID
    
        '=' type=VarType
     ';' ;

Define returns Define:
    {Define}
    'define'
    
          (defineList+=DefineDecl)+  
    ;

DefineRegExp returns DefineRegExp:
    {DefineRegExp}
    'regexp'
    
          (defineRegsList+=DefineRegExpDecl)+  
    ;

Counter returns Counter:
    {Counter}
    'counter'
    name=ID
         ('('range=Subrange')')
    '{'
          (((initial+=TemporalInExpr  ) |
        ('reset:'  resetPred+=TemporalInExpr  ) |
        ('inc:'  incPred+=TemporalExpression  ) |
        ('dec:'  decPred+=TemporalExpression  ) |
        ('overflow:'  overflowMethod+=OverflowMethod  ) |
        ('underflow:'  underflowMethod+=OverflowMethod  )) ';')*
    '}';

Monitor returns Monitor:
    {Monitor}
    'monitor'
         type=VarType
    name=ID
    '{'
        (((('ini' | 'initially')?  initial+=TemporalInExpr  ) |
        (('G' | 'trans')  safety+=TemporalInExpr  ) |
        (('always' | 'alw')  stateInv+=TemporalInExpr  )) ';')*
    '}';

Pattern returns Pattern:
    {Pattern}
    'pattern'
    name=ID
        ( '('params=PatternParamList')')?
    ('{'
        ('var'  varDeclList+=VarDecl  )*
        ((('ini' | 'initially')?  initial+=TemporalInExpr   |
        ('G' | 'trans')  safety+=TemporalInExpr   |
        ('always' | 'alw')  stateInv+=TemporalInExpr   |
        ('GF' | 'alwEv' | 'alwaysEventually')  justice+=TemporalInExpr  ) ';')+
    '}');

Predicate returns Predicate:
    {Predicate}
    'predicate'
    name=ID
    
         ('('params=TypedParamList')' | '()')
         (':' body=TemporalExpression ';' | '{' body=TemporalExpression '}')
    ;

LTLGar returns LTLGar:
    {LTLGar}
    ('guarantee' | 'gar')
    (name=ID
    
        ( '{'params=TypedParamList'}')? ':')?
        ((('ini' | 'initially' |  safety=('G' | 'trans') |
         stateInv=('always' | 'alw') |
         justice=('GF' | 'alwEv'| 'alwaysEventually'))?
         (temporalExpr=QuantifierExpr)) |
         (trig=Trigger))
     ';' ;

LTLAsm returns LTLAsm:
    {LTLAsm}
    ('assumption' | 'asm')
    (name=ID
        ( '{'params=TypedParamList'}')? ':')?
        ((('ini' | 'initially' |  safety=('G' | 'trans') |
         stateInv=('always' | 'alw') |
         justice=('GF' | 'alwEv'| 'alwaysEventually'))?
         (temporalExpr=QuantifierExpr)) |
         (trig=Trigger))
     ';' ;

EXGar returns EXGar:
    {EXGar}
    ('guarantee' | 'gar')
    (name=ID ':')?
    
        ('GE'  elements+=TemporalInExpr ( "," elements+=TemporalInExpr)*   |
        'GEF' regExpPointer=[DefineRegExpDecl] |
        'GEF' regExp=RegExp)
     ';' ;

TemporalInExpr returns TemporalExpression:
    TemporalImpExpr
    ({TemporalInExpr.left=current}
    (not?='not')?
    
         operator=('in')
         '{' values+=ValueInRange ( "," values+=ValueInRange)* '}' )?
    ;

TemporalImpExpr returns TemporalExpression:
    TemporalIffExpr
    ({TemporalImpExpr.left=current}
    
    
         operator=('->' | 'implies')
         implication=TemporalImpExpr)?
    ;

TemporalIffExpr returns TemporalExpression:
    TemporalOrExpr
    ({TemporalIffExpr.elements+=current}
    
    
         operator=('<->' | 'iff')
          elements+=TemporalOrExpr  )*
    ;

TemporalOrExpr returns TemporalExpression:
    TemporalAndExpr
    ({TemporalOrExpr.elements+=current}
    
    
          operator+=('|' | 'or' | 'xor')  
          elements+=TemporalAndExpr  )*
    ;

TemporalAndExpr returns TemporalExpression:
    TemporalRelationalExpr
    ({TemporalAndExpr.elements+=current}
    
    
          operator+=('&' | 'and')  
          elements+=TemporalRelationalExpr  )*
    ;

TemporalRelationalExpr returns TemporalExpression:
    TemporalRemainderExpr
    ({TemporalRelationalExpr.left=current}
    
    
         operator=('='|'!='|'<'|'>'|'<='|'>=')
         right=TemporalRemainderExpr)?
    ;

TemporalRemainderExpr returns TemporalExpression:
    TemporalAdditiveExpr
    ({TemporalRemainderExpr.left=current}
    
    
         operator=('mod' | '%')
         right=TemporalAdditiveExpr)?
    ;

TemporalAdditiveExpr returns TemporalExpression:
    TemporalMultiplicativeExpr
    ({TemporalAdditiveExpr.elements+=current}
    
    
          operator+=('+'|'-')  
          elements+=TemporalMultiplicativeExpr  )*
    ;

TemporalMultiplicativeExpr returns TemporalExpression:
    TemporalBinaryExpr
    ({TemporalMultiplicativeExpr.elements+=current}
    
    
          operator+=('*'|'/')  
          elements+=TemporalBinaryExpr  )*
    ;

TemporalBinaryExpr returns TemporalExpression:
    TemporalUnaryExpr
    ({TemporalBinaryExpr.elements+=current}
    
    
          operator+=('S' | 'SINCE' | 'T' | 'TRIGGERED')  
          elements+=TemporalUnaryExpr  )*
    ;

TemporalUnaryExpr returns TemporalExpression:
    TemporalPrimaryExpr |
    {TemporalUnaryExpr}
    
    
        ( kinds=ID)?
         tue=TemporalUnaryExpr
    ;

TemporalPrimaryExpr returns TemporalExpression:
    Constant | '(' QuantifierExpr ')' |
    {TemporalPrimaryExpr}
    
    
         predPatt=[PredicateOrPatternReferrable]
         ('(' predPattParams+=TemporalInExpr ( "," predPattParams+=TemporalInExpr)* ')' | '()')|
        ( operator=ID)?
        ( pointer=[Referrable|ID])?
        ( tpe=TemporalExpression)?
        (  ('['index+=TemporalExpression']')*  )?
        ( temporalExpression=TemporalExpression)?
        ( regexp=RegExp)?
        ( regexpPointer=[DefineRegExpDecl])?
    ;

Constant returns TemporalExpression:
    {Constant}
    
    
         (booleanValue='FALSE' | booleanValue='false' | booleanValue='TRUE' | booleanValue='true' |
         integerValue=INT)
    ;

QuantifierExpr returns TemporalExpression:
    TemporalInExpr |
    {QuantifierExpr}
    
    
         (operator=('forall' | 'exists')
         domainVar=DomainVarDecl '.' 
         temporalExpr=(QuantifierExpr))
    ;

ValueInRange returns ValueInRange:
    {ValueInRange}
    
    
         const=[TypeConstant] |
         int=INT |
         (from=INT
    multi?= '-' 
         to=INT) |
         booleanValue=('TRUE' |'FALSE' | 'true' | 'false')
    ;

TypeConstant returns TypeConstant:
    {TypeConstant}
    
    name=TypeConstantLiteral;

DefineRegExpDecl returns DefineRegExpDecl:
    {DefineRegExpDecl}
    
    name=ID
    
        ':=' exp=RegExp
     ';' ;

VarDecl returns VarDecl:
    {VarDecl}
    
    
         type=VarType
    name=ID
     ';' ;

DefineDecl returns DefineDecl:
    {DefineDecl}
    
    ((name=ID
    
        ':=' simpleExpr=TemporalExpression) |
          (name=ID ('['dimensions+=SizeDefineDecl']')+  
        ':=' innerArray=DefineArray))
     ';' ;

PatternParam returns PatternParam:
    {PatternParam}
    
    name=ID;

TypedParam returns TypedParam:
    {TypedParam}
    
    
         type=VarType
    name=ID
    ;

DomainVarDecl returns DomainVarDecl:
    {DomainVarDecl}
    
    name=ID
    
        'in' domainType=VarType
    ;

VarType returns VarType:
    {VarType}
    
    (name='boolean' |
        'Int' '('subr=Subrange')' |
         '{' const+=TypeConstant ( "," const+=TypeConstant)* '}'  |
         type=[TypeDef])
          ('['dimensions+=SizeDefineDecl']')*  
    ;

Subrange returns Subrange:
    {Subrange}
    
    
         from=SizeDefineDecl
        '..' to=SizeDefineDecl
    ;

SizeDefineDecl returns SizeDefineDecl:
    {SizeDefineDecl}
    
    
         value=INT |
         name=[DefineDecl] |
         '('arithExp=TemporalExpression')'
    ;

DefineArray returns DefineArray:
    {DefineArray}
    
    
          '{'(simpleExprs+=TemporalExpression ( "," simpleExprs+=TemporalExpression)*  )'}' |
          '{'(innerArrays+=DefineArray ( "," innerArrays+=DefineArray)*  )'}'
    ;

BooleanTerm returns BooleanTerm:
    {BooleanTerm}
    
    '['
         relExpr=TemporalInExpr
    ']';

BinaryRegExp returns RegExp:
    UnaryRegExp
    ({BinaryRegExp.left=current}
    
         (op=('&' | '|'))?
         right=UnaryRegExp)*
    ;

UnaryRegExp returns RegExp:
    CompRegExp
    ({UnaryRegExp.left=current}
    ((kleened?='*')|
    (questionMark?='?')|
    (plus?='+')|
    (haveExactRepetition?='{'
         exactRepetition=INT '}')|
    (haveAtLeast?='{'
         atLeast=INT ',' '}')|
    (haveRange?='{'
    
    
         (from=INT|
         fromDefine=[DefineDecl]) ','
         (to=INT|
         toDefine=[DefineDecl]) '}')))?
    ;

CompRegExp returns RegExp:
    PrimaryRegExp |
    ({CompRegExp}
    
    
         (comp='~')
         left=CompRegExp)
    ;

enum VarOwner returns VarOwner:
                SYS = 'sys' | ENV = 'env' | AUX = 'aux' | SYS='output' | SYS='out' | SYS='sysvar' | ENV='input' | ENV='in' | ENV='envvar' | AUX='auxvar';

enum OverflowMethod returns OverflowMethod:
                KEEP = 'keep' | FALSE = 'false' | MODULO = 'modulo';

PatternParamList returns PatternParamList:
    {PatternParamList}
    
    
          params+=PatternParam ( "," params+=PatternParam)*  
    ;

TypedParamList returns TypedParamList:
    {TypedParamList}
    
    
          params+=TypedParam ( "," params+=TypedParam)*  
    ;

Trigger returns Trigger:
    {Trigger}
    'trig'
         (initPointer=[DefineRegExpDecl] |
         initRegExp=RegExp) '|=>'
         (effectPointer=[DefineRegExpDecl] |
         effectRegExp=RegExp)
    ;

PrimaryRegExp returns RegExp:
'(' RegExp ')' | val=('TRUE' |'FALSE' | 'true' | 'false') | assrt=BooleanTerm  | empty?='()';

@Override
terminal SL_COMMENT:
    ('//' | '--') !('\n' | '\r')* ('\r'? '\n')?;

TypeConstantLiteral:
    ID | INT;

